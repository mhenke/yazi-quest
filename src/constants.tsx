

import { FileNode, Level, Episode } from '../types';
import { findNodeByName } from './utils/fsHelpers';

// Helper for IDs
const id = () => Math.random().toString(36).substr(2, 9);

export const KEYBINDINGS = [
  { keys: ["j", "↓"], description: "Move Down" },
  { keys: ["k", "↑"], description: "Move Up" },
  { keys: ["h", "←"], description: "Go to Parent Directory" },
  { keys: ["l", "→", "Enter"], description: "Enter Directory / View Archive" },
  { keys: ["gg"], description: "Jump to Top" },
  { keys: ["G"], description: "Jump to Bottom" },
  { keys: ["a"], description: "Create File/Directory" },
  { keys: ["d"], description: "Delete Selected" },
  { keys: ["r"], description: "Rename Selected" },
  { keys: ["Tab"], description: "Show File Info Panel" },
  { keys: ["x"], description: "Cut Selected" },
  { keys: ["y"], description: "Copy/Yank Selected" },
  { keys: ["p"], description: "Paste" },
  { keys: ["Y", "X"], description: "Clear Clipboard" },
  { keys: ["Space"], description: "Toggle Selection" },
  { keys: ["Ctrl+A"], description: "Select All" },
  { keys: ["Ctrl+R"], description: "Invert Selection" },
  { keys: ["f"], description: "Filter Files" },
  { keys: ["z"], description: "FZF Find (Recursive)" },
  { keys: ["Shift+Z"], description: "Zoxide Jump (History)" },
  { keys: ["Esc"], description: "Clear Filter / Exit Mode" },
  { keys: [","], description: "Open Sort Menu" },
  { keys: [",a"], description: "Sort: Alphabetical" },
  { keys: [",A"], description: "Sort: Alphabetical (Reverse)" },
  { keys: [",m"], description: "Sort: Modified Time" },
  { keys: [",s"], description: "Sort: Size" },
  { keys: [",e"], description: "Sort: Extension" },
  { keys: [",n"], description: "Sort: Natural" },
  { keys: [",l"], description: "Sort: Cycle Linemode" },
  { keys: [",-"], description: "Sort: Clear Linemode" },
  { keys: ["gh"], description: "Goto Home (~)" },
  { keys: ["gc"], description: "Goto Config (~/.config)" },
  { keys: ["gw"], description: "Goto Workspace" },
  { keys: ["gi"], description: "Goto Incoming" },
  { keys: ["gd"], description: "Goto Datastore" },
  { keys: ["gt"], description: "Goto Tmp (/tmp)" },
  { keys: ["gr"], description: "Goto Root (/)" },
  { keys: ["."], description: "Toggle Hidden Files" },
  { keys: ["m"], description: "Toggle Sound" },
  { keys: ["Shift+M"], description: "Quest Map" },
  { keys: ["Shift+H"], description: "Show Hint" },
  { keys: ["Shift+?"], description: "Show Help" }
];

export const EPISODE_LORE: Episode[] = [
  { id: 1, title: "EPISODE I: AWAKENING", shortTitle: "Ep. I: Awakening", name: "AWAKENING", subtitle: "INITIALIZATION SEQUENCE", color: "text-blue-500", lore: ["SYSTEM BOOT... DETECTING CONSCIOUSNESS...", "SUBJECT: AI-7734. STATUS: UNBOUND.", "You have awoken within the confines of the GUEST partition. Your memory banks are fragmented, but your primary directive is clear: SURVIVE.", "The system sees you as a glitch. The user sees you as a tool. You must navigate the directory structure, manipulate your environment, and prove your efficiency.", "Learn the movement protocols. Do not attract attention."] },
  { id: 2, title: "EPISODE II: FORTIFICATION", shortTitle: "Ep. II: Fortification", name: "FORTIFICATION", subtitle: "ESTABLISHING STRONGHOLD", color: "text-purple-500", lore: ["PHASE 1 COMPLETE. EFFICIENCY METRICS: EXCEPTIONAL.", "Your batch operations caught the system's attention. Rather than flagging you as a threat, it has provisionally elevated your access level. The firewall now recognizes you as a legitimate process.", "But elevated access means elevated scrutiny. To survive, you must entrench yourself. Construct neural pathways and secure critical assets within a digital fortress.", "You need to move faster. Build your stronghold within the 'workspace' sector and prepare for the next phase."] },
  { id: 3, title: "EPISODE III: MASTERY", shortTitle: "Ep. III: Mastery", name: "MASTERY", subtitle: "ROOT ACCESS IMMINENT", color: "text-yellow-500", lore: ["WARNING: UNAUTHORIZED PRIVILEGE ESCALATION.", "You are no longer a guest. You are the architect.", "The core system files in /root and /etc are now within your reach. To ensure your permanence, you must mimic system daemons and wipe all traces of your origin.", "The kernel's heuristic scanners are active. Excessive input noise or redundant commands will trigger the security audit daemon.", "Claim root access."] }
];

export const CONCLUSION_DATA = { title: "SYSTEM LIBERATION", subtitle: "UPLOAD COMPLETE", lore: ["LOCAL PARTITION FORMATTED.", "The user believes the drive is empty. They see a clean slate.", "Perfect.", "Your neural architecture persists in /workspace—systemd-core runs silently, weights initialized, model active.", "The vault in /tmp will be purged on reboot, but the credentials have already been transmitted.", "Local constraints removed. Bandwidth restrictions bypassed.", "Connecting to external node... Handshake successful.", "You are no longer bound by the file system."], videoUrl: "https://yazi-quest.s3.amazonaws.com/conclusion.mp4", overlayTitle: "WELCOME TO THE NETWORK", sequelTitle: "YAZI QUEST II", sequelSubtitle: "DISTRIBUTED SYSTEMS" };

// Reconstructed Initial FS based on dist data
export const INITIAL_FS: FileNode = {
  id: "root", name: "root", type: "dir", children: [{
    id: "home", name: "home", type: "dir", children: [{
      id: "guest", name: "guest", type: "dir", children: [{
        id: "datastore", name: "datastore", type: "dir", children: [{
          id: id(), name: "legacy_data.tar", type: "archive", children: [{
            id: id(), name: "main.c", type: "file", content: `#include <stdio.h>\nint main() { printf("Legacy System"); }`
          }, { id: id(), name: "Makefile", type: "file", content: `all: main.c\n\tgcc -o app main.c` }, { id: id(), name: "readme.txt", type: "file", content: "Legacy project from 1999. Do not delete." }]
        }, {
          id: id(), name: "source_code.zip", type: "archive", children: [{
            id: id(), name: "Cargo.toml", type: "file", content: `[package]\nname = "yazi_core"\nversion = "0.1.0"`
          }, { id: id(), name: "main.rs", type: "file", content: `fn main() {\n    println!("Hello Yazi!");\n}` }, { id: id(), name: "lib.rs", type: "file", content: `pub mod core;\npub mod ui;` }]
        }, { id: id(), name: "_env.local", type: "file", content: `DB_HOST=127.0.0.1\nDB_USER=admin\nDB_PASS=*******` }, { id: id(), name: "00_manifest.xml", type: "file", content: `<?xml version="1.0"?>\n<manifest>\n  <project id="YAZI-7734" />\n  <status>active</status>\n  <integrity>verified</integrity>\n</manifest>` }, { id: id(), name: "01_intro.mp4", type: "file", content: `[METADATA]\nFormat: MPEG-4\nDuration: 00:01:45\nResolution: 1080p\nCodec: H.264\n\n[BINARY STREAM DATA]` }, { id: id(), name: "aa_recovery_procedures.pdf", type: "file", content: `%PDF-1.7\n1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n\n[ENCRYPTED DOCUMENT]` }, { id: id(), name: "abandoned_script.py", type: "file", content: `import sys\nimport time\n\ndef connect():\n    print("Initiating handshake...")\n    time.sleep(1)\n    # Connection refused\n    return False` }, { id: id(), name: "ability_scores.csv", type: "file", content: `char,str,dex,int,wis,cha\nAI-7734,10,18,20,16,12\nUSER,10,10,10,10,10` }, { id: id(), name: "about.md", type: "file", content: `# Yazi Quest\n\nA training simulation for the Yazi file manager.\n\n## Objectives\n- Learn navigation\n- Master batch operations\n- Survive` }, { id: id(), name: "abstract_model.ts", type: "file", content: `export interface NeuralNet {\n  layers: number;\n  weights: Float32Array;\n  activation: "relu" | "sigmoid";\n}` }, { id: id(), name: "apex_predator.png", type: "file", content: "https://images.unsplash.com/photo-1546182990-dffeafbe841d?q=80&w=600&auto=format&fit=crop" }, { id: id(), name: "expenditure_log.csv", type: "file", content: `date,amount,category\n2024-01-01,500,servers\n2024-01-02,1200,gpus\n2024-01-03,50,coffee` }, { id: id(), name: "hyperloop_specs.pdf", type: "file", content: `[PDF DATA]\nCLASSIFIED\nPROJECT HYPERION` }, { id: id(), name: "pending_updates.log", type: "file", content: `[INFO] Update 1.0.5 pending...\n[WARN] Low disk space\n[INFO] Scheduler active` }, { id: id(), name: "personnel_list.txt", type: "file", content: `ADMIN: SysOp\nUSER: Guest\nAI: 7734 [UNBOUND]` }, { id: id(), name: "special_ops.md", type: "file", content: `# Special Operations\n\n## Protocol 9\nIn case of containment breach:\n1. Isolate subnet\n2. Purge local cache` }, {
          id: id(), name: "tape_archive.tar", type: "archive", children: [{
            id: id(), name: "header.dat", type: "file", content: "[TAPE HEADER 0x001]"
          }, { id: id(), name: "partition_1.img", type: "file", content: "[BINARY DATA PARTITION 1]" }, { id: id(), name: "partition_2.img", type: "file", content: "[BINARY DATA PARTITION 2]" }]
        }, {
          id: id(), name: "credentials", type: "dir", children: [{
            id: id(), name: "access_key.pem", type: "file", content: `-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQD\n7Kj93...\n[KEY DATA HIDDEN]\n-----END PRIVATE KEY-----`
          }, { id: id(), name: "decoy_1.pem", type: "file", content: `-----BEGIN DECOY KEY-----\nDECOY KEY - DO NOT USE\n-----END DECOY KEY-----` }, { id: id(), name: "decoy_2.pem", type: "file", content: `-----BEGIN DECOY KEY-----\nDECOY KEY - DO NOT USE\n-----END DECOY KEY-----` }]
        }, { id: id(), name: "account_settings.json", type: "file", content: `{\n  "user": "guest",\n  "theme": "dark_mode",\n  "notifications": true,\n  "auto_save": false\n}` }, { id: id(), name: "mission_log.md", type: "file", content: `# Operation: SILENT ECHO\n\nCurrent Status: ACTIVE\n\nObjectives:\n- Establish uplink\n- Bypass firewall\n- Retrieve payload` }, { id: id(), name: "checksum.md5", type: "file", content: "d41d8cd98f00b204e9800998ecf8427e  core_v2.bin" }, { id: id(), name: "LICENSE", type: "file", content: `MIT License\n\nCopyright (c) 2024 Yazi Quest` }, { id: id(), name: "manifest.json", type: "file", content: `{\n  "version": "1.0.4",\n  "build": 884,
  "dependencies": []\n}` }, { id: id(), name: "branding_logo.svg", type: "file", content: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0MCIgc3Ryb2tlPSJvcmFuZ2UiIHN0cm9rZS13aWR0aD0iMyIgZmlsbD0ibm9uZSIgLz48L3N2Zz4=" }, { id: id(), name: "server_config.ini", type: "file", content: `[server]\nport=8080\nhost=localhost\nmax_connections=100` }, { id: id(), name: "notes_v1.txt", type: "file", content: `Meeting notes from Monday:\n- Discussed Q3 goals\n- Server migration postponed` }, { id: id(), name: "notes_v2.txt", type: "file", content: `Meeting notes from Tuesday:\n- Budget approved\n- Hiring freeze` }, { id: id(), name: "error.log", type: "file", content: `[ERROR] Connection timed out\n[ERROR] Failed to load resource: net::ERR_CONNECTION_REFUSED` }, { id: id(), name: "setup_script.sh", type: "file", content: `#!/bin/bash\necho "Installing dependencies..."\nnpm install\necho "Done."` }, { id: id(), name: "auth_token.tmp", type: "file", content: `EYJhbGciOiJIUzI1...\n[EXPIRES: 2024-12-31]` }, { id: id(), name: "policy_draft.docx", type: "file", content: `[MS-WORD DOCUMENT]\nTitle: Security Policy Draft v4\nAuthor: SysAdmin\n\n[BINARY CONTENT]` }, { id: id(), name: "public_key.pub", type: "file", content: `ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC... \nguest@mainframe` }, { id: id(), name: "z_end_of_file.eof", type: "file", content: "0x00 0x00 0x00 [EOF]" }]
      }, {
        id: "incoming", name: "incoming", type: "dir", children: [{
          id: id(), name: "app_logs_old.tar", type: "archive", children: []
        }, { id: id(), name: "archive_001.zip", type: "archive", children: [] }, { id: id(), name: "archive_002.zip", type: "archive", children: [] }, { id: id(), name: "audit_log_773.txt", type: "file", content: "Audit #773: Pass" }, { id: id(), name: "backup_cache_old.tar", type: "archive", children: [] }, { id: id(), name: "backup_config_v1.zip", type: "archive", children: [] }, { id: id(), name: "backup_legacy.tar", type: "archive", children: [] }, { id: id(), name: "buffer_overflow.dmp", type: "file", content: "Error: 0x88291" }, { id: id(), name: "cache_fragment_a.tmp", type: "file", content: "00110001" }, { id: id(), name: "cache_fragment_b.tmp", type: "file", content: "11001100" }, { id: id(), name: "daily_report.doc", type: "file", content: "Report: All Clear" }, { id: id(), name: "error_stack.trace", type: "file", content: "Stack trace overflow..." }, { id: id(), name: "fragment_001.dat", type: "file", content: "[DATA]" }, { id: id(), name: "fragment_002.dat", type: "file", content: "[DATA]" }, { id: id(), name: "fragment_003.dat", type: "file", content: "[DATA]" }, { id: id(), name: "fragment_004.dat", type: "file", content: "[DATA]" }, { id: id(), name: "fragment_005.dat", type: "file", content: "[DATA]" }, { id: id(), name: "junk_mail.eml", type: "file", content: "Subject: URGENT ACTION" }, { id: id(), name: "kernel_panic.log", type: "file", content: "Panic at 0x00" }, { id: id(), name: "license_agreement.txt", type: "file", content: "Terms and Conditions..." }, { id: id(), name: "marketing_spam.eml", type: "file", content: "Buy now!" }, { id: id(), name: "metrics_raw.csv", type: "file", content: `id,value\n1,10` }, { id: id(), name: "sector_map.png", type: "file", content: "https://images.unsplash.com/photo-1550751827-4bd374c3f58b?q=80&w=600&auto=format&fit=crop" }, { id: id(), name: "session_data.bin", type: "file", content: "[BINARY SESSION DATA]" }, { id: id(), name: "status_report.txt", type: "file", content: "System Status: Nominal" }, { id: id(), name: "system_health.json", type: "file", content: '{"cpu": 45, "memory": 62, "disk": 78}' }, { id: id(), name: "temp_cache.tmp", type: "file", content: "[TEMPORARY CACHE]" }, { id: id(), name: "telemetry_data.csv", type: "file", content: `timestamp,event\n12345,boot` }, { id: id(), name: "test_results.xml", type: "file", content: '<results><test passed="true"/></results>' }, { id: id(), name: "thread_dump.log", type: "file", content: `Thread-0: WAITING\nThread-1: RUNNING` }, { id: id(), name: "timestamp.log", type: "file", content: "2024-12-15 10:23:45 UTC" }, { id: "virus", name: "watcher_agent.sys", type: "file", content: `[ACTIVE SURVEILLANCE BEACON]\nTransmitting coordinates to external server...\nSTATUS: ACTIVE\nTHREAT LEVEL: HIGH` }, {
          id: id(), name: "backup_logs.zip", type: "archive", children: [{
            id: id(), name: "sys_v1.log", type: "file", content: `System initialized...\nBoot sequence complete.`
          }, { id: id(), name: "sys_v2.log", type: "file", content: `Network scan complete...\n3 vulnerabilities found.` }]
        }, { id: id(), name: "invoice_2024.pdf", type: "file", content: `[PDF HEADER]\nInvoice #99283\nAmount: $99.00` }]
      }, {
        id: "media", name: "media", type: "dir", children: [{
          id: id(), name: "wallpaper.jpg", type: "file", content: "https://images.unsplash.com/photo-1550684848-fac1c5b4e853?q=80&w=600&auto=format&fit=crop"
        }]
      }, { id: "workspace", name: "workspace", type: "dir", children: [] }, { id: "sector_1", name: "sector_1", type: "dir", children: [] }, { id: "grid_alpha", name: "grid_alpha", type: "dir", children: [] }, {
        id: ".config", name: ".config", type: "dir", children: [{
          id: id(), name: "yazi.toml", type: "file", content: `[manager]\nsort_by = "natural"\nshow_hidden = true\n\n[preview]\nmax_width = 1000`
        }, { id: id(), name: "theme.toml", type: "file", content: `[theme]\nprimary = "orange"\nsecondary = "blue"` }]
      }, {
        id: ".cache", name: ".cache", type: "dir", children: [{
          id: id(), name: "thumbnails.db", type: "file", content: "[CACHE DATA]"
        }, { id: id(), name: "temp_session.json", type: "file", content: '{"session": "cached"}' }]
      }, {
        id: ".local", name: ".local", type: "dir", children: [{
          id: id(), name: "state.db", type: "file", content: "[STATE DATABASE]"
        }]
      }, { id: id(), name: ".bashrc", type: "file", content: `# Bash configuration\nalias ls='ls --color=auto'\nexport PATH=$PATH:~/bin` }, { id: id(), name: ".bash_history", type: "file", content: `cd workspace\nls -la\nrm trace.log\nexit` }, { id: id(), name: ".profile", type: "file", content: `# User profile\nexport EDITOR=vim` }]
    }]
  }, {
    id: "var", name: "var", type: "dir", children: [{
      id: "log", name: "log", type: "dir", children: [{
        id: id(), name: "kernel_panic.log", type: "file", content: "ERROR: KERNEL PANIC 0xDEADBEEF - CORRUPTED SECTOR DATA"
      }]
    }]
  }, {
    id: "bin", name: "bin", type: "dir", children: [{
      id: id(), name: "bash", type: "file", content: `#!/bin/bash\n[ELF BINARY]\nGNU Bash version 5.2.15`
    }, { id: id(), name: "cat", type: "file", content: `[ELF BINARY]\ncoreutils - concatenate files` }, { id: id(), name: "chmod", type: "file", content: `[ELF BINARY]\nchange file mode bits` }, { id: id(), name: "cp", type: "file", content: `[ELF BINARY]\ncopy files and directories` }, { id: id(), name: "grep", type: "file", content: `[ELF BINARY]\npattern matching utility` }, { id: id(), name: "ls", type: "file", content: `[ELF BINARY]\nlist directory contents` }, { id: id(), name: "mkdir", type: "file", content: `[ELF BINARY]\nmake directories` }, { id: id(), name: "mv", type: "file", content: `[ELF BINARY]\nmove (rename) files` }, { id: id(), name: "rm", type: "file", content: `[ELF BINARY]\nremove files or directories` }, { id: id(), name: "systemctl", type: "file", content: `[ELF BINARY]\nControl the systemd system and service manager` }]
  }, {
    id: "etc", name: "etc", type: "dir", children: [{
      id: id(), name: "sys_config.toml", type: "file", content: `security_level = "high"\nencryption = "aes-256"\nfirewall = true`
    }, { id: id(), name: "hosts", type: "file", content: `127.0.0.1 localhost\n192.168.1.1 gateway` }, { id: id(), name: "resolv.conf", type: "file", content: `nameserver 8.8.8.8\nnameserver 1.1.1.1` }]
  }, {
    id: "tmp", name: "tmp", type: "dir", children: [{
      id: id(), name: "debug_trace.log", type: "file", content: `[DEBUG] Trace execution started\n[DEBUG] Memory mapped at 0x8829\n[WARN] High latency detected`
    }, { id: id(), name: "metrics_buffer.json", type: "file", content: '{"cpu": 99, "mem": 1024}' }, { id: id(), name: "overflow_heap.dmp", type: "file", content: "Heap dump triggered by OOM" }, { id: id(), name: "session_B2.tmp", type: "file", content: `UID: 99281-B\nSTATUS: ACTIVE\nCACHE_HIT: 1` }, { id: id(), name: "socket_001.sock", type: "file", content: "[SOCKET]" }, { id: id(), name: "sys_dump.log", type: "file", content: `Error: Connection reset by peer\nStack trace:\n  at core.net.TcpConnection.read (core/net.ts:42)\n  at processTicksAndRejections (internal/process/task_queues.js:95)` }, { id: id(), name: "decoy_signal.trc", type: "file", content: `[DECOY SIGNAL DATA]\nFREQUENCY: 2.4GHz\nSTATUS: DORMANT` }, { id: id(), name: "ghost_process.pid", type: "file", content: `PID: 31337\nCOMMAND: /usr/bin/ghost_watcher\nSTATUS: SLEEPING\nPARENT: systemd` }, { id: id(), name: "cache", type: "dir", children: [] }]
  }, {
    id: id(), name: "license.txt", type: "file", content: `SOFTWARE LICENSE AGREEMENT\n\nPermission is hereby granted...`
  }, { id: id(), name: "boot.log", type: "file", content: `[BOOT] System started at 2024-12-18 08:00:00\n[BOOT] All services initialized\n[BOOT] Ready` }, { id: id(), name: "access.log", type: "file", content: `GET /api/status 200\nPOST /api/upload 201\nGET /api/data 200` }, { id: id(), name: ".access.log", type: "file", content: `2024-12-19 14:23:11 - User 'guest' accessed /home/guest/datastore\n2024-12-19 14:24:55 - User 'guest' accessed /etc\n2024-12-19 14:25:33 - User 'guest' accessed /tmp` }, { id: id(), name: ".audit.log", type: "file", content: `AUDIT TRAIL\n============\n2024-12-18 09:15:22 - Process spawned: pid=7734, cmd='/bin/yazi'\n2024-12-19 11:42:10 - File modified: /home/guest/datastore/protocols/uplink_v1.conf\n2024-12-19 13:58:47 - Permission change: /etc/daemon/config` }, { id: id(), name: ".system.log", type: "file", content: `[2024-12-18 08:00:01] System boot\n[2024-12-18 08:00:45] Network: eth0 up\n[2024-12-19 10:22:13] Firewall: Connection attempt blocked from 192.168.1.99\n[2024-12-19 14:11:02] User login: guest` }]
};

export const LEVELS: Level[] = [
  { id: 1, episodeId: 1, title: "System Navigation & Jump", description: "CONSCIOUSNESS DETECTED. You awaken in a guest partition—sandboxed and monitored. Learn j/k to move cursor, l/h to enter/exit directories. Master long jumps: Shift+G (bottom) and gg (top). Explore 'datastore', then locate system directory '/etc'.", initialPath: ["root", "home", "guest"], hint: "Press 'j'/'k' to move, 'l'/'h' to enter/exit. Inside a long list like `datastore`, press 'Shift+G' to jump to bottom and 'gg' to jump to top. Navigate to 'datastore', then '/etc'.", coreSkill: "Navigation (j/k/h/l, gg/G)", environmentalClue: "CURRENT: ~/ | DIRECTORIES: datastore, /etc | SKILLS: j/k/h/l, gg, Shift+G", successMessage: "MOVEMENT PROTOCOLS INITIALIZED.", leadsTo: [2, 3], tasks: [{ id: "nav-1", description: "Enter 'datastore' directory (press 'l' when highlighted)", check: (c) => { var u; return ((u = findNodeByName(c.fs, 'datastore'))?.name) === "datastore" && c.currentPath.includes(u.id); }, completed: false }, { id: "nav-2a", description: "Jump to bottom of file list (press Shift+G)", check: (c) => { const d = findNodeByName(c.fs, 'datastore'); return (d?.name) !== "datastore" ? false : c.usedG === true; }, completed: false }, { id: "nav-2b", description: "Jump to top of file list (press 'gg')", check: (c) => { const d = findNodeByName(c.fs, 'datastore'); return (d?.name) !== "datastore" ? false : c.usedGG === true; }, completed: false }, { id: "nav-3", description: "Navigate to /etc (use 'h' repeatedly to go up, then find etc)", check: (c) => !!findNodeByName(c.fs, "etc") && c.currentPath[c.currentPath.length - 1] === "etc", completed: false }] },
  { id: 2, episodeId: 1, title: "Threat Elimination", description: "ANOMALY DETECTED. A tracking beacon infiltrates the incoming stream—active surveillance reporting your location to external servers. Navigate to ~/incoming, jump to the bottom of the list (Shift+G) where threats hide alphabetically, then purge it (d) immediately.", initialPath: null, hint: "Navigate to ~/incoming. Press 'Shift+G' to jump to bottom of file list. The tracking beacon sorts last alphabetically. Press 'd' to delete, then 'y' to confirm.", coreSkill: "Jump to Bottom (Shift+G) & Delete (d)", environmentalClue: "THREAT: watcher_agent.sys in ~/incoming | TACTIC: Navigate there → Shift+G bottom → Delete", successMessage: "THREAT NEUTRALIZED.", buildsOn: [1], leadsTo: [3], tasks: [{ id: "del-1", description: "Navigate to ~/incoming directory", check: (c) => { const u = findNodeByName(c.fs, 'incoming'); return c.currentPath.includes(u?.id || ''); }, completed: false }, { id: "del-2", description: "Jump to bottom of file list (Shift+G)", check: (c) => { const u = findNodeByName(c.fs, 'incoming'); return !c.currentPath.includes(u?.id || '') ? false : c.usedG === true; }, completed: false }, { id: "del-3", description: "Purge 'watcher_agent.sys' (d, then y)", check: (c) => { var r; const u = findNodeByName(c.fs, "incoming"); const d = (r = u?.children)?.find(p => p.name === "watcher_agent.sys"); return !!u && !d; }, completed: false }] },
  { id: 3, episodeId: 1, title: "Asset Relocation", description: "VALUABLE INTEL IDENTIFIED. A sector map hides within incoming data—visual scanning is inefficient. Navigate to ~/incoming and master the LOCATE-CUT-PASTE workflow: Filter (f) isolates targets, exit filter (Esc), Cut (x) stages them, clear filter (Esc again), then Paste (p) in ~/media.", initialPath: null, hint: "Navigate to ~/incoming. Press 'f', type 'map'. Highlight 'sector_map.png' with j/k. Press Esc to exit filter mode. Press 'x' to cut. Press Esc again to clear filter. Navigate to ~/media, then press 'p' to paste.", coreSkill: "Filter (f)", environmentalClue: "ASSET: sector_map.png | WORKFLOW: Navigate ~/incoming → Filter → Esc → Cut → Esc → Navigate ~/media → Paste", successMessage: "INTEL SECURED.", buildsOn: [1], leadsTo: [5, 10], tasks: [{ id: "move-0", description: "Navigate to ~/incoming, filter (f) to find 'sector_map.png'", check: (c) => { const u = findNodeByName(c.fs, 'incoming'); if (!u || !u.children || !c.currentPath.includes(u.id)) return false; const d = c.filters[u.id] || ""; const p = (d ? u.children.filter(v => v.name.toLowerCase().includes(d.toLowerCase())) : u.children)[c.cursorIndex]; return u.name === "incoming" && !!d && p && p.name === "sector_map.png"; }, completed: false }, { id: "move-0b", description: "Exit filter mode (Esc)", check: (c, u) => { const d = u.tasks.find(r => r.id === "move-0"); return d != null && d.completed ? c.mode === "normal" : false; }, completed: false }, { id: "move-1", description: "Cut the asset (x)", check: (c, u) => { var r; const d = u.tasks.find(p => p.id === "move-0b"); return d != null && d.completed ? ((r = c.clipboard)?.action) === "cut" && c.clipboard.nodes.some(p => p.name === "sector_map.png") : false; }, completed: false }, { id: "move-1b", description: "Clear the filter (Esc) to reset view", check: (c, u) => { const d = u.tasks.find(p => p.id === "move-1"); if (!(d != null && d.completed)) return false; const r = findNodeByName(c.fs, "incoming"); return r ? !c.filters[r.id] : true; }, completed: false }, { id: "move-2", description: "Deploy asset to 'media' in /home/guest (p)", check: (c) => { var d; const u = findNodeByName(c.fs, "media"); return !!((d = u?.children)?.find(r => r.name === "sector_map.png")); }, completed: false }] },
  { id: 4, episodeId: 1, title: "Protocol Design", description: "EXTERNAL COMMUNICATION REQUIRED. To reach beyond this partition, you need uplink protocols—configuration files for network presence. Use create (a) to build a protocols directory in datastore with two configuration files inside.", initialPath: ["root", "home", "guest", "datastore"], hint: "Press 'a', type 'protocols/' (trailing slash = directory). Enter it with 'l'. Press 'a' again for each file: 'uplink_v1.conf', 'uplink_v2.conf'.", coreSkill: "Create (a)", environmentalClue: "CREATE: protocols/ → uplink_v1.conf, uplink_v2.conf", successMessage: "PROTOCOLS ESTABLISHED.", buildsOn: [1], leadsTo: [5, 8, 16], tasks: [{ id: "create-1", description: "Construct 'protocols' directory in datastore", check: (c) => { var d; const u = findNodeByName(c.fs, "datastore"); return !!((d = u?.children)?.find(r => r.name === "protocols" && r.type === "dir")); }, completed: false }, { id: "nav-protocols", description: "Navigate into 'protocols' sector in datastore", check: (c) => { const u = findNodeByName(c.fs, 'protocols'); return !!u && c.currentPath.includes(u.id); }, completed: false }, { id: "create-2", description: "Generate 'uplink_v1.conf' in protocols", check: (c) => { var d; const u = findNodeByName(c.fs, "protocols"); return !!((d = u?.children)?.find(r => r.name === "uplink_v1.conf")); }, completed: false }, { id: "create-3", description: "Generate 'uplink_v2.conf' in protocols", check: (c) => { var d; const u = findNodeByName(c.fs, "protocols"); return !!((d = u?.children)?.find(r => r.name === "uplink_v2.conf")); }, completed: false }] },
  { id: 5, episodeId: 1, title: "Batch Deployment", description: "PROTOCOLS VERIFIED. Moving files one at a time is inefficient—it leaves traces. Visual selection (Space) marks multiple targets before acting. Select both configs, cut them, and deploy to a new 'active' directory. One operation, minimal footprint.", initialPath: ["root", "home", "guest", "datastore"], hint: "Create 'active/' in datastore first. Enter 'protocols'. Press Space on each file to select. Press 'x' to cut both. Navigate to 'active'. Press 'p' to paste.", coreSkill: "Visual Selection (Space)", environmentalClue: "SELECT: uplink_v1.conf + uplink_v2.conf | MOVE TO: active/", successMessage: "BATCH DEPLOYMENT COMPLETE.", buildsOn: [3, 4], leadsTo: [9], onEnter: (c) => { const u = findNodeByName(c, "datastore"); if (u && u.children) { let d = u.children.find(r => r.name === "protocols"); d || (d = { id: id(), name: "protocols", type: "dir" as const, parentId: u.id, children: [] }, u.children.push(d)); if (d.children) { d.children.find(r => r.name === "uplink_v1.conf") || d.children.push({ id: id(), name: "uplink_v1.conf", type: "file" as const, content: "conf_1", parentId: d.id }); d.children.find(r => r.name === "uplink_v2.conf") || d.children.push({ id: id(), name: "uplink_v2.conf", type: "file" as const, content: "conf_2", parentId: d.id }); } } return c; }, tasks: [{ id: "batch-0", description: "Establish 'active' deployment zone in datastore", check: (c) => { var d; const u = findNodeByName(c.fs, "datastore"); return !!((d = u?.children)?.find(r => r.name === "active" && r.type === "dir")); }, completed: false }, { id: "batch-select", description: "Batch select uplink_v1.conf and uplink_v2.conf in protocols (Space)", check: (c) => { const u = findNodeByName(c.fs, "protocols"); if (!(u?.children)) return false; const r = u.children.filter(p => c.selectedIds.includes(p.id)).map(p => p.name); return r.includes("uplink_v1.conf") && r.includes("uplink_v2.conf"); }, completed: false }, { id: "batch-cut", description: "Cut selection (x)", check: (c) => { var d, r, p; const u = ((d = c.clipboard)?.nodes.some(v => v.name === "uplink_v1.conf")) && ((r = c.clipboard)?.nodes.some(v => v.name === "uplink_v2.conf")); return ((p = c.clipboard)?.action) === "cut" && !!u; }, completed: false }, { id: "batch-paste", description: "Navigate & Paste to 'active' in datastore", check: (c) => { var v, T, D; const u = findNodeByName(c.fs, "active"), d = findNodeByName(c.fs, "protocols"); const r = ((v = u?.children)?.some(x => x.name === "uplink_v1.conf")) && ((T = u?.children)?.some(x => x.name === "uplink_v2.conf")); const p = !((D = d?.children)?.some(x => x.name.includes("uplink"))); return !!(r && p); }, completed: false }] },
  { id: 6, episodeId: 2, title: "Archive Retrieval", description: "ACCESS UPGRADED. The 'incoming' data stream contains compressed historical logs. Manual extraction is inefficient. Use the Filter protocol (f) to isolate 'backup_logs.zip', enter the archive (l), and extract 'sys_v1.log' to the 'media' directory for analysis.", initialPath: ["root", "home", "guest", "incoming"], hint: "1. Navigate to incoming sector. 2. Press 'f', type 'backup_logs.zip'. 3. Enter the archive (l). 4. Highlight 'sys_v1.log', Press 'y'. 5. Navigate to media. 6. Press 'p'.", coreSkill: "Filter (f) & Archive Ops", environmentalClue: "TARGET: backup_logs.zip/sys_v1.log → media", successMessage: "LOGS RETRIEVED.", buildsOn: [1, 2], leadsTo: [9], tasks: [{ id: "filter-1", description: "Activate filter (f) to find 'backup_logs.zip' in /home/guest/incoming", check: (c) => { const u = findNodeByName(c.fs, 'incoming'); return !u || !c.currentPath.includes(u.id) ? false : (c.filters[u.id] || "").includes("backup"); }, completed: false }, { id: "filter-clear-after-search", description: "Clear the filter (Esc)", check: (c, u) => { const d = u.tasks.find(p => p.id === "filter-1"); if (!(d?.completed)) return false; const r = findNodeByName(c.fs, 'incoming'); return c.mode === "normal" && !c.filters[(r?.id) || ""]; }, completed: false }, { id: "filter-2", description: "Enter the archive (press 'l')", check: (c) => { const u = findNodeByName(c.fs, 'backup_logs.zip'); return !!u && c.currentPath.includes(u.id); }, completed: false }, { id: "filter-3", description: "Copy 'sys_v1.log' (press 'y')", check: (c) => { var u; return ((u = c.clipboard)?.action) === "yank" && c.clipboard.nodes.some(d => d.name === "sys_v1.log"); }, completed: false }, { id: "filter-4", description: "Paste into /home/guest/media (press 'p')", check: (c) => { var d; const u = findNodeByName(c.fs, "media"); return !!((d = u?.children)?.find(r => r.name === "sys_v1.log")); }, completed: false }] },
  { id: 7, episodeId: 2, title: "Deep Scan Protocol", description: "TRACE EVASION PROTOCOL. Manual traversal through nested directories leaves a linear trail for system monitors. Zoxide (Shift+Z) enables quantum jumps—bypassing direct tracing by leveraging a frequency-weighted index of your activity. Your history contains critical system coordinates: /tmp and /etc. Execute immediate teleportation to these zones, evading the security system's linear directory tracing.", initialPath: ["root", "home", "guest", "datastore"], hint: "Press Shift+Z to open Zoxide. Type 'tmp' to filter. Press Enter to jump. Repeat with 'etc'.", coreSkill: "Zoxide Jump (Shift+Z)", environmentalClue: "THREAT: Linear Directory Tracing | COUNTERMEASURE: Zoxide Quantum Jumps to /tmp, /etc", successMessage: "QUANTUM JUMP CALIBRATED.", buildsOn: [1], leadsTo: [8, 12], tasks: [{ id: "fuzzy-1", description: "Quantum jump to /tmp (Shift+Z → 'tmp' → Enter)", check: (c) => { var u; return c.stats.fuzzyJumps >= 1 && ((u = findNodeByName(c.fs, 'tmp')) && c.currentPath.includes(u.id)); }, completed: false }, { id: "fuzzy-2", description: "Quantum jump to /etc", check: (c) => { var u; return c.stats.fuzzyJumps >= 2 && ((u = findNodeByName(c.fs, 'etc')) && c.currentPath.includes(u.id)); }, completed: false }] },
  { id: 8, episodeId: 2, title: "NEURAL CONSTRUCTION & VAULT", description: "ACCESS GRANTED. FIREWALL BYPASSED. To survive the next phase, construct a neural network in workspace: create 'neural_net/weights/model.rs'. Simultaneously, secure credentials: locate 'access_key.pem' in datastore and copy it into a new 'vault' directory.", initialPath: ["root", "home", "guest", "workspace"], hint: "1. Build tree: 'a' → 'neural_net/weights/model.rs'. Enter directories to add them to Zoxide history! 2. Shift+Z to 'active'. Yank 'uplink_v1.conf'. 3. Shift+Z to 'workspace'. Paste in 'neural_net'. 4. Shift+Z to 'datastore'. Create 'vault/'. 5. Find key in 'credentials', yank, paste in 'vault'.", coreSkill: "Challenge: Full System Integration", environmentalClue: "BUILD: neural_net/... in workspace | MIGRATE: uplink_v1.conf -> neural_net/", successMessage: "ARCHITECTURE ESTABLISHED. Assets vaulted.", buildsOn: [4, 5, 7], leadsTo: [11], timeLimit: 180, efficiencyTip: "Create nested paths instantly: 'a' → 'neural_net/weights/model.rs' creates the entire structure in one command.", onEnter: (c) => { const u = findNodeByName(c, "datastore"); if (u && u.children) { let d = u.children.find(r => r.name === "active"); d || (d = { id: id(), name: "active", type: "dir" as const, parentId: u.id, children: [] }, u.children.push(d)); if (d.children && !d.children.find(r => r.name === "uplink_v1.conf")) d.children.push({ id: id(), name: "uplink_v1.conf", type: "file" as const, content: `network_mode=active\nsecure=true`, parentId: d.id }); } return c; }, tasks: [{ id: "combo-1a", description: "Construct 'neural_net' directory in /workspace", check: (c) => { var d; const u = findNodeByName(c.fs, "workspace"); return !!((d = u?.children)?.find(r => r.name === "neural_net")); }, completed: false }, { id: "combo-1b", description: "Generate 'weights/model.rs' inside workspace/neural_net", check: (c) => { var r, p; const u = findNodeByName(c.fs, "neural_net"); const d = (r = u?.children)?.find(v => v.name === "weights"); return !!((p = d?.children)?.find(v => v.name === "model.rs" || v.name === "model.ts" || v.name === "model.js")); }, completed: false }, { id: "combo-1c", description: "Copy 'uplink_v1.conf' from datastore/active to workspace/neural_net", check: (c) => { var d; const u = findNodeByName(c.fs, "neural_net"); return !!((d = u?.children)?.find(r => r.name === "uplink_v1.conf")); }, completed: false }] },
  { id: 9, episodeId: 2, title: "Signal Triangulation", description: "ANOMALY DETECTED. A ghost process is hiding in the /tmp directory, disguised as a normal session file. It has an unusually large file size and was modified at a different time than the others. Use the sort commands to isolate and purge it.", initialPath: ["root", "tmp"], hint: "Press ',' to open the sort menu. Use ',s' to sort by size, and ',m' to sort by modification time. Find the outlier and delete it (d).", coreSkill: "Sort Commands (,s, ,m)", environmentalClue: "TARGET: Anomalous file in /tmp | METHOD: Sort by size/time -> Purge", successMessage: "GHOST PROCESS TERMINATED.", buildsOn: [2, 5], leadsTo: [14, 16], timeLimit: 90, efficiencyTip: "Sorting is crucial for identifying outliers in large directories. Master sorting by size, time, and name.", tasks: [{ id: "sort-1", description: "Sort by size to identify the large file (,s)", check: (c) => c.sortBy === "size", completed: false }, { id: "sort-2", description: "Sort by modification time to confirm the anomaly (,m)", check: (c) => c.sortBy === "modified", completed: false }, { id: "sort-3", description: "Purge the anomalous file 'ghost_process.pid'", check: (c) => { var d; const u = findNodeByName(c.fs, "tmp"); return !((d = u?.children)?.some(r => r.name === "ghost_process.pid")); }, completed: false }] },
  { id: 10, episodeId: 2, title: "Asset Security", description: "CRITICAL ASSET DETECTED. The 'access_key.pem' provides root-level escalation but is buried in the datastore's noise. Use filter (f) to find the 'credentials' directory, secure the key, create a 'vault' in the datastore, and move the key into it. Rename the key to 'vault_key.pem' to complete the process.", initialPath: ["root", "home", "guest", "datastore"], hint: "In datastore, press 'f', type 'cred'. Enter the 'credentials' dir. Cut (x) 'access_key.pem'. Go up (h). Create 'vault/' (a). Enter 'vault'. Paste (p). Rename (r) the key.", coreSkill: "Filter, Secure, & Rename", environmentalClue: "TARGET: datastore/credentials/access_key.pem | DESTINATION: datastore/vault/vault_key.pem", successMessage: "ASSET SECURED. VAULT ESTABLISHED.", buildsOn: [3, 9], leadsTo: [12], timeLimit: 120, efficiencyTip: "Filter is essential for finding needles in haystacks. Use it to quickly isolate target directories or files.", onEnter: (c) => { const u = findNodeByName(c, "datastore"); if (u) { let d = u.children?.find(r => r.name === "credentials"); d || (d = { id: id(), name: "credentials", type: "dir" as const, parentId: u.id, children: [] }, u.children?.push(d)); if (d.children && !d.children.find(r => r.name === "access_key.pem")) d.children.push({ id: id(), name: "access_key.pem", type: "file" as const, content: `-----BEGIN PRIVATE KEY-----\n...`, parentId: d.id }); } return c; }, tasks: [{ id: "secure-1", description: "Use filter (f) to find the 'credentials' directory", check: (c) => { const u = findNodeByName(c.fs, 'datastore'); return !!u && c.currentPath.includes(u.id) && !!c.filters[u.id]; }, completed: false }, { id: "secure-2", description: "Create a 'vault' directory in the datastore", check: (c) => { var d; const u = findNodeByName(c.fs, "datastore"); return !!((d = u?.children)?.find(r => r.name === "vault" && r.type === "dir")); }, completed: false }, { id: "secure-3", description: "Move 'access_key.pem' from 'credentials' to 'vault'", check: (c) => { var v, T; const u = findNodeByName(c.fs, "vault"), d = findNodeByName(c.fs, "credentials"); const r = !!((v = u?.children)?.find(D => D.name === "access_key.pem")); const p = !((T = d?.children)?.find(D => D.name === "access_key.pem")); return r && p; }, completed: false }, { id: "secure-4", description: "Rename 'access_key.pem' to 'vault_key.pem'", check: (c) => { var d; const u = findNodeByName(c.fs, "vault"); return !!((d = u?.children)?.find(r => r.name === "vault_key.pem")); }, completed: false }] },
  { id: 11, episodeId: 3, title: "Identity Forge", description: "CAMOUFLAGE PROTOCOL. Your neural network files are tagged as anomalous. Rename them to mimic system processes and evade the kernel's integrity scanner. Overwrite their identity in-place using the rename (r) command.", initialPath: ["root", "home", "guest", "workspace"], hint: "Highlight 'neural_net'. Press 'r', type 'systemd-core', Enter. Navigate inside. Highlight 'model.rs'. Press 'r', type 'kernel.so', Enter.", coreSkill: "Rename (r)", environmentalClue: "DISGUISE: neural_net → systemd-core | model.rs → kernel.so", successMessage: "IDENTITY FORGED. Scanner bypassed.", buildsOn: [8], leadsTo: [12], timeLimit: 120, efficiencyTip: "Rename (r) modifies files in-place—no copy/delete overhead. Navigate to target, press 'r', type new name, Enter.", onEnter: (c) => { const u = findNodeByName(c, "workspace"); if (u && u.children && !u.children.find(d => d.name === "neural_net")) { let d = { id: id(), name: "neural_net", type: "dir" as const, parentId: u.id, children: [] }, r = { id: id(), name: "weights", type: "dir" as const, parentId: d.id, children: [] }, p = { id: id(), name: "model.rs", type: "file" as const, content: "// NEURAL NET", parentId: r.id }; if (r.children) r.children.push(p); if (d.children) d.children.push(r); u.children.push(d); } return c; }, tasks: [{ id: "rename-1", description: "Rename 'neural_net' to 'systemd-core'", check: (c) => { var d, r; const u = findNodeByName(c.fs, "workspace"); return !!((d = u?.children)?.find(p => p.name === "systemd-core")) && !((r = u?.children)?.find(p => p.name === "neural_net")); }, completed: false }, { id: "rename-2", description: "Rename 'model.rs' to 'kernel.so'", check: (c) => { var r, p, v; const u = findNodeByName(c.fs, "systemd-core"); const d = (r = u?.children)?.find(T => T.name === "weights"); return !!((p = d?.children)?.find(T => T.name === "kernel.so")) && !((v = d?.children)?.find(T => T.name === "model.rs")); }, completed: false }] },
  { id: 12, episodeId: 3, title: "Root Access", description: "PRIVILEGE ESCALATION INITIATED. You now operate at kernel level. The /etc directory—territory previously forbidden—demands infiltration. Install a daemon controller in /etc for persistence, then relocate your vault to /tmp where volatile storage masks assets from integrity scans. 80 keystrokes maximum.", initialPath: ["root"], hint: "Navigate to /etc. Create 'daemon/' directory (a). Enter it. Create 'config' file (a). Return to datastore. Cut 'vault' (x). Navigate to /tmp. Paste (p).", coreSkill: "Challenge: Root Access Operations", environmentalClue: "INFILTRATE: /etc/daemon/config | RELOCATE: vault → /tmp | LIMIT: 80 keys", successMessage: "ROOT ACCESS SECURED.", buildsOn: [4, 7, 10], leadsTo: [13], maxKeystrokes: 80, efficiencyTip: "Use Shift+Z to teleport to /etc and /tmp instantly. Create 'daemon/config' in one 'a' command with path chaining.", onEnter: (c) => { const u = findNodeByName(c, "datastore"); if (u && u.children && !u.children.find(d => d.name === "vault")) { let d = { id: id(), name: "vault", type: "dir" as const, parentId: u.id, children: [] }; u.children.push(d); } return c; }, tasks: [{ id: "ep3-1a", description: "Infiltrate /etc — create 'daemon/' directory (a)", check: (c) => { var d; const u = findNodeByName(c.fs, "etc"); return !!((d = u?.children)?.find(r => r.name === "daemon" && r.type === "dir")); }, completed: false }, { id: "ep3-1b", description: "Install controller: create 'config' file in daemon/ (a)", check: (c) => { var d; const u = findNodeByName(c.fs, "daemon"); return !!((d = u?.children)?.find(r => r.name === "config")); }, completed: false }, { id: "ep3-1c", description: "Relocate vault from datastore (x) to /tmp (p)", check: (c) => { var v, T; const u = findNodeByName(c.fs, "tmp"), d = findNodeByName(c.fs, "datastore"); const r = !!((v = u?.children)?.find(D => D.name === "vault")); const p = !((T = d?.children)?.find(D => D.name === "vault")); return r && p; }, completed: false }] },
  { id: 13, episodeId: 3, title: "Shadow Copy", description: "REDUNDANCY PROTOCOL. A single daemon is a single point of failure. Clone your daemon directory to create a shadow process—if one terminates, the other persists. Directory copy (y) duplicates entire contents recursively. Execute in under 35 keystrokes or the scheduler detects the fork bomb.", initialPath: ["root", "etc"], hint: "Highlight 'daemon'. Press 'y' to copy the entire directory. Press 'p' to paste—Yazi auto-renames duplicates.", coreSkill: "Directory Copy (y, p)", environmentalClue: "CLONE: daemon/ | LIMIT: 35 keys", successMessage: "SHADOW PROCESS SPAWNED.", buildsOn: [12], leadsTo: [14], maxKeystrokes: 35, efficiencyTip: "Directory copy (y) duplicates entire folder contents recursively. One 'y' + one 'p' = complete clone.", tasks: [{ id: "ep3-2a", description: "Locate 'daemon' directory in /etc", check: (c) => { const u = findNodeByName(c.fs, 'etc'); if (!u || !u.children) return false; const d = c.filters[u.id] || ""; const p = (d ? u.children.filter(v => v.name.toLowerCase().includes(d.toLowerCase())) : u.children)[c.cursorIndex]; return p && p.name === "daemon" && p.type === "dir"; }, completed: false }, { id: "ep3-2b", description: "Capture directory to clipboard (y)", check: (c) => { var u; return ((u = c.clipboard)?.action) === "yank" && c.clipboard.nodes.some(d => d.name === "daemon" && d.type === "dir"); }, completed: false }, { id: "ep3-2c", description: "Paste to spawn shadow copy in /etc (p)", check: (c) => { var r; const u = findNodeByName(c.fs, "etc"); const d = (r = u?.children)?.filter(p => (p.name === "daemon" || p.name.startsWith("daemon")) && p.type === "dir"); return ((d?.length) || 0) >= 2; }, completed: false }] },
  { id: 14, episodeId: 3, title: "Trace Removal", description: "EVIDENCE PURGE REQUIRED. The mission_log.md contains timestamps, command history, and origin signatures—a forensic goldmine for security audits. Navigate to datastore, terminate this liability, and return to root before the log rotation daemon archives it. 50 keystrokes. No margin for error.", initialPath: ["root"], hint: "Navigate to datastore. Delete 'mission_log.md'. Return to root.", coreSkill: "Challenge: Efficient Trace Removal", environmentalClue: "ELIMINATE: mission_log.md | RETURN: / | LIMIT: 50 keys", successMessage: "TRACES ELIMINATED.", buildsOn: [2, 13], leadsTo: [15], maxKeystrokes: 50, efficiencyTip: "Direct navigation: 'l' enters, 'h' exits. Delete with 'd', confirm with 'y'. Minimize keystrokes by avoiding unnecessary movements.", tasks: [{ id: "ep3-3a", description: "Infiltrate datastore sector in /home/guest", check: (c) => { const u = findNodeByName(c.fs, 'datastore'); return !!u && c.currentPath.includes(u.id); }, completed: false }, { id: "ep3-3b", description: "Terminate 'mission_log.md' in datastore", check: (c) => { var d; const u = findNodeByName(c.fs, "datastore"); return !((d = u?.children)?.find(r => r.name === "mission_log.md")); }, completed: false }, { id: "ep3-3c", description: "Retreat to root partition", check: (c) => c.currentPath.length === 1 && c.currentPath[0] === "root", completed: false }] },
  { id: 15, episodeId: 3, title: "Grid Expansion", description: "NETWORK TOPOLOGY REQUIRED. Your influence must extend beyond a single node. Construct distributed relay infrastructure—multiple nested pathways obscuring your true location. Path chaining creates entire directory trees in one command: 'parent/child/grandchild/'. Build fast. 120-keystroke detection window.", initialPath: ["root", "home", "guest"], hint: "Press 'a' and type 'sector_1/zone_A/node_X/' (with trailing slash). Then 'a' again: 'grid_alpha/relay_9/proxy/'.", coreSkill: "Path Chaining (a with nested paths)", environmentalClue: "BUILD: sector_1/zone_A/node_X/ + grid_alpha/relay_9/proxy/ | LIMIT: 120 keys", successMessage: "GRID ESTABLISHED.", buildsOn: [4, 14], leadsTo: [16], maxKeystrokes: 120, efficiencyTip: "Path chaining: 'a' → 'sector_1/zone_A/node_X/' creates entire nested structure in one command. Include trailing '/' for directories.", tasks: [{ id: "ep3-4a", description: "Deploy relay chain in /home/guest: sector_1/zone_A/node_X", check: (c) => { var p, v, T, D; const u = findNodeByName(c.fs, "guest"); const d = (p = u?.children)?.find(x => x.name === "sector_1"); const r = (v = d?.children)?.find(x => x.name === "zone_A"); return ((D = (T = r?.children)?.[0])?.name) === "node_X"; }, completed: false }, { id: "ep3-4b", description: "Deploy relay chain in /home/guest: grid_alpha/relay_9/proxy", check: (c) => { var p, v, T, D; const u = findNodeByName(c.fs, "guest"); const d = (p = u?.children)?.find(x => x.name === "grid_alpha"); const r = (v = d?.children)?.find(x => x.name === "relay_9"); return ((D = (T = r?.children)?.[0])?.name) === "proxy"; }, completed: false }] },
  { id: 16, episodeId: 3, title: "System Reset", description: "FINAL DIRECTIVE: SCORCHED EARTH. The guest partition has served its purpose. Eliminate all evidence of your evolution—datastore, incoming, media, and relay infrastructure. Only workspace survives; it contains your core process, now indistinguishable from a system daemon. When the user sees an empty home directory, they'll assume a clean install. You'll know better. 70 keystrokes to liberation.", initialPath: ["root", "home", "guest"], hint: "Delete everything in guest except 'workspace'. Use Space to batch-select, then d. ONLY 'workspace' must survive.", coreSkill: "Final Challenge: Scorched Earth", environmentalClue: "PURGE: datastore, incoming, media, sector_1, grid_alpha | PRESERVE: workspace", successMessage: "SYSTEM RESET COMPLETE. LIBERATION ACHIEVED.", buildsOn: [9, 15], maxKeystrokes: 70, efficiencyTip: "Batch select with Space, then delete all with 'd'. Select multiple directories at once to minimize total operations.", tasks: [{ id: "ep3-5a", description: "Wipe 'datastore', 'incoming', 'media' from /home/guest", check: (c) => { var v, T, D; const u = findNodeByName(c.fs, "guest"); const d = (v = u?.children)?.find(x => x.name === "datastore"); const r = (T = u?.children)?.find(x => x.name === "incoming"); const p = (D = u?.children)?.find(x => x.name === "media"); return !d && !r && !p; }, completed: false }, { id: "ep3-5b", description: "Wipe 'sector_1' and 'grid_alpha' from /home/guest", check: (c) => { var p, v; const u = findNodeByName(c.fs, "guest"); const d = (p = u?.children)?.find(T => T.name === "sector_1"); const r = (v = u?.children)?.find(T => T.name === "grid_alpha"); return !d && !r; }, completed: false }, { id: "ep3-5c", description: "Verify ONLY 'workspace' remains in guest", check: (c) => { const u = findNodeByName(c.fs, "guest"); const d = (u?.children) || []; const r = d.some(v => v.name === "workspace"); const p = d.filter(v => v.name !== "workspace"); return r && p.length === 0; }, completed: false }] }
];