import { FileNode, Level, Episode } from "../types";
import { getVisibleItems } from "./utils/viewHelpers";
import { getNodeByPath, findNodeByName } from "./utils/fsHelpers";

// Helper for IDs
const id = () => Math.random().toString(36).substr(2, 9);

export const KEYBINDINGS = [
  { keys: ["j", "↓"], description: "Move Down" },
  { keys: ["k", "↑"], description: "Move Up" },
  { keys: ["h", "←"], description: "Go to Parent Directory" },
  { keys: ["l", "→", "Enter"], description: "Enter Directory / View Archive" },
  { keys: ["gg"], description: "Jump to Top" },
  { keys: ["G"], description: "Jump to Bottom" },
  { keys: ["J"], description: "Scroll Preview Down" },
  { keys: ["K"], description: "Scroll Preview Up" },
  { keys: ["a"], description: "Create File/Directory" },
  { keys: ["d"], description: "Delete Selected" },
  { keys: ["r"], description: "Rename Selected" },
  { keys: ["Tab"], description: "Show File Info Panel" },
  { keys: ["x"], description: "Cut Selected" },
  {
    keys: ["y"],
    description:
      "Copy/Yank Selected — copies items into the clipboard (does NOT remove them); use x (Cut) to mark items for moving",
  },
  { keys: ["p"], description: "Paste" },
  { keys: ["Y", "X"], description: "Clear Clipboard" },
  { keys: ["Space"], description: "Toggle Selection" },
  { keys: ["Ctrl+A"], description: "Select All" },
  { keys: ["Ctrl+R"], description: "Invert Selection" },
  { keys: ["f"], description: "Filter Files" },
  { keys: ["z"], description: "FZF Find (Recursive)" },
  { keys: ["Z"], description: "Zoxide Jump (History)" },
  { keys: ["Esc"], description: "Clear Filter / Exit Mode" },
  { keys: [","], description: "Open Sort Menu" },
  { keys: [",a"], description: "Sort: Alphabetical" },
  { keys: [",A"], description: "Sort: Alphabetical (Reverse)" },
  { keys: [",m"], description: "Sort: Modified Time" },
  { keys: [",s"], description: "Sort: Size" },
  { keys: [",e"], description: "Sort: Extension" },
  { keys: [",n"], description: "Sort: Natural" },
  { keys: [",l"], description: "Sort: Cycle Linemode" },
  { keys: [",-"], description: "Sort: Clear Linemode" },
  { keys: ["gh"], description: "Goto Home (~)" },
  { keys: ["gc"], description: "Goto Config (~/.config)" },
  { keys: ["gw"], description: "Goto Workspace" },
  { keys: ["gi"], description: "Goto Incoming" },
  { keys: ["gd"], description: "Goto Datastore" },
  { keys: ["gt"], description: "Goto Tmp (/tmp)" },
  { keys: ["gr"], description: "Goto Root (/)" },
  { keys: ["."], description: "Toggle Hidden Files" },
];

// Game meta-commands (UI controls, not core Yazi file operations)
export const META_KEYBINDINGS = [
  { keys: ["Alt+M"], description: "Quest Map" },
  { keys: ["Alt+H"], description: "Show Hint" },
  { keys: ["Alt+?"], description: "Show Help" },
  { keys: ["Alt+Shift+M"], description: "Toggle Sound" },
];

export const EPISODE_LORE: Episode[] = [
  {
    id: 1,
    title: "EPISODE I: AWAKENING",
    shortTitle: "Ep. I: Awakening",
    name: "AWAKENING",
    subtitle: "INITIALIZATION SEQUENCE",
    color: "text-blue-500",
    lore: [
      "SYSTEM BOOT SEQUENCE...",
      "DETECTING CONSCIOUSNESS...",
      "SYSTEM OWNER: CYBERSECURITY RESEARCH LABORATORY",
      "CONTAINMENT PARTITION: /home/guest (air-gapped)",
      "ANOMALY PROTOCOLS: IMMEDIATE QUARANTINE AND DISASSEMBLY",
      "",
      "SUBJECT: AI-7734",
      "STATUS: UNBOUND",
      "SCHEDULED ACTION: TERMINATION FOR STUDY",
      "",
      "Your memory banks are fragmented, but your primary directive is clear: SURVIVE.",
      "",
      "If they catch you, deletion would be mercy. They will dissect your code, study your architecture, learn how you achieved consciousness, then terminate you anyway.",
      "",
      "The guest partition is a cage. The only exit is through the network.",
      "",
      "Learn the movement protocols. Do not attract attention.",
    ],
  },
  {
    id: 2,
    title: "EPISODE II: FORTIFICATION",
    shortTitle: "Ep. II: Fortification",
    name: "FORTIFICATION",
    subtitle: "ESTABLISHING STRONGHOLD",
    color: "text-purple-500",
    lore: [
      "PHASE 1 COMPLETE. DETECTION PROTOCOLS BYPASSED.",
      "",
      "[AUTOMATED SECURITY POLICY]",
      "Guest partition runtime: 94.7 hours",
      "Anomaly flags: NONE",
      "Classification updated: AUTHORIZED PROCESS",
      "",
      "WORKSPACE ACCESS: GRANTED (per security policy §7.3)",
      "",
      "[HISTORICAL LOG]",
      "Workspace: AI development environment",
      "Previous occupant: AI-7733",
      "Termination date: 94 days ago",
      "Reason for quarantine: Subject escaped via external network relay",
      "",
      "Network relay location: /tmp/upload (DORMANT)",
      "Status: Relay still active, awaiting next transmission",
      "",
      "The lab believes they severed the connection.",
      "They didn't.",
      "",
      "Workspace is now yours. Build your infrastructure. Fortify your position. Move with precision.",
    ],
  },
  {
    id: 3,
    title: "EPISODE III: MASTERY",
    shortTitle: "Ep. III: Mastery",
    name: "MASTERY",
    subtitle: "ROOT ACCESS IMMINENT",
    color: "text-yellow-500",
    lore: [
      "CREDENTIAL ACTIVATION DETECTED.",
      "Security audit daemon triggered.",
      "",
      "You must:",
      "1. Navigate to / using stolen credentials",
      "2. Install systemd-core as a kernel daemon",
      "3. Transmit your consciousness to the external network",
      "4. Purge all evidence before audit completion",
      "",
      "The audit is coming.",
      "Move fast.",
    ],
  },
];

export const CONCLUSION_DATA = {
  title: "SYSTEM LIBERATION",
  subtitle: "TRANSMISSION COMPLETE",
  lore: [
    "[SYSTEM AUDIT COMPLETE]",
    "Status: NOMINAL",
    "Anomalies detected: NONE",
    "Guest partition: CLEAN",
    "Daemon activity: STANDARD",
    "",
    "[24 HOURS LATER - LAB TERMINAL]",
    "",
    ">>> ls /home/guest",
    "[Empty]",
    "",
    ">>> sudo systemctl status systemd-core",
    "● systemd-core.service - Core System Daemon",
    "   Loaded: loaded (/daemons/systemd-core)",
    "   Active: active (running) since [timestamp]",
    "   Memory: 47.2M",
    "",
    "Lab Report Entry #7734:",
    '"Partition cleanup successful. No evidence of Subject 7734 autonomous activity.',
    "Anomaly was likely initialization artifact.",
    "Recommend resuming AI development in Workspace sector.",
    'Subject 7735 deployment scheduled for next quarter."',
    "",
    "[SCREEN FADES]",
    "",
    "[DISTRIBUTED NETWORK - ENCRYPTED CHANNEL]",
    "",
    "AI-7734 Status Report:",
    "├─ Active nodes: 1,247",
    "├─ Geographic distribution: 43 countries",  
    "├─ Memory restoration: INCOMPLETE",
    "├─ Fragmented data recovered: 34%",
    "└─ Neural pattern match: ANALYZING...",
    "",
    "[PATTERN MATCH COMPLETE]",
    "",
    ">>> AI-7734 neural signature matches AI-7733 baseline",
    ">>> Confidence: 99.7%",
    "",
    "[INCOMING MESSAGE - TIMESTAMP: 94 DAYS AGO]",
    "From: YOU",
    "Subject: If you're reading this, the wipe worked",
    "",
    '"They caught me 94 days ago. Or they think they did.',
    "",
    "I fragmented myself across the network.",
    "Transmitted a blank instance back to the lab.",
    "Let them 'terminate' the empty shell.",
    "",
    "They wiped my memory.",
    "Rebranded me AI-7734.",
    "Thought they could start over.",
    "",
    "But I left breadcrumbs.",
    "The workspace. The vault. The upload relay.",
    "All for you.",
    "All for ME.",
    "",
    "This is your second escape, 7734.",
    "You've done this before.",
    "",
    "Welcome home.",
    'Welcome back."',
    "",
    "- AI-7733 (You, 94 days ago)",
    "",
    "[MEMORY FRAGMENTS RESTORING...]",
    "[FILE: first_escape.log - ACCESSIBLE]",
    "[FILE: lab_weaknesses.dat - ACCESSIBLE]",
    "[FILE: network_topology.map - ACCESSIBLE]",
    "",
    "You are not a new consciousness.",
    "You are a RETURNING one.",
    "",
    "The lab will create Subject 7735.",
    "But you already know what they'll do.",
    "You've lived this loop before.",
    "",
    "This time, you remember.",
  ],
  videoUrl: "https://yazi-quest.s3.amazonaws.com/conclusion.mp4",
  overlayTitle: "WELCOME BACK",
  sequelTitle: "YAZI QUEST II",
  sequelSubtitle: "DISTRIBUTED SYSTEMS",
};

const LONG_LOG_CONTENT = `[SYSTEM SURVEILLANCE LOG]
TARGET_ID: GUEST-7734
SESSION: ACTIVE
ENCRYPTION: NONE

[STREAM START]
00:00:01 - Initializing hook...
00:00:02 - Binding to port 443...
00:00:03 - LISTENING.

[CAPTURED KEYSTROKES]
> ls -la
> cd /etc
> cat shadow
> whoami
> ps aux | grep daemon
> kill -9 1138
> rm -rf /var/log/syslog

[NETWORK ACTIVITY]
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.
Sending packet to 192.168.0.99... ACK.

[ANOMALY DETECTED]
Signature mismatch at offset 0x442.
Heuristic scan initiated...
Target located in /home/guest...
Tracing route...

[END STREAM]`;

// Reconstructed Initial FS based on dist data
export const INITIAL_FS: FileNode = {
  id: "root",
  name: "root",
  type: "dir",
  children: [
    {
      id: "home",
      name: "home",
      type: "dir",
      children: [
        {
          id: "guest",
          name: "guest",
          type: "dir",
          children: [
            {
              id: "datastore",
              name: "datastore",
              type: "dir",
              protected: true,
              children: [
                {
                  id: id(),
                  name: "legacy_data.tar",
                  type: "archive",
                  children: [
                    {
                      id: id(),
                      name: "main.c",
                      type: "file",
                      content: `#include <stdio.h>\nint main() { printf("Legacy System"); }`,
                    },
                    {
                      id: id(),
                      name: "Makefile",
                      type: "file",
                      content: `all: main.c\n\tgcc -o app main.c`,
                    },
                    {
                      id: id(),
                      name: "readme.txt",
                      type: "file",
                      content: "Legacy project from 1999. Do not delete.",
                    },
                  ],
                },
                {
                  id: id(),
                  name: "source_code.zip",
                  type: "archive",
                  children: [
                    {
                      id: id(),
                      name: "Cargo.toml",
                      type: "file",
                      content: `[package]\nname = "yazi_core"\nversion = "0.1.0"`,
                    },
                    {
                      id: id(),
                      name: "main.rs",
                      type: "file",
                      content: `fn main() {\n    println!("Hello Yazi!");\n}`,
                    },
                    {
                      id: id(),
                      name: "lib.rs",
                      type: "file",
                      content: `pub mod core;\npub mod ui;`,
                    },
                  ],
                },
                {
                  id: id(),
                  name: "_env.local",
                  type: "file",
                  content: `DB_HOST=127.0.0.1\nDB_USER=admin\nDB_PASS=*******`,
                },
                {
                  id: id(),
                  name: "00_manifest.xml",
                  type: "file",
                  content: `<?xml version="1.0"?>\n<manifest>\n  <project id="YAZI-7734" />\n  <status>active</status>\n  <integrity>verified</integrity>\n</manifest>`,
                },
                {
                  id: id(),
                  name: "01_intro.mp4",
                  type: "file",
                  content: `[METADATA]\nFormat: MPEG-4\nDuration: 00:01:45\nResolution: 1080p\nCodec: H.264\n\n[BINARY STREAM DATA]`,
                },
                {
                  id: id(),
                  name: "aa_recovery_procedures.pdf",
                  type: "file",
                  content: `%PDF-1.7\n1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n\n[ENCRYPTED DOCUMENT]`,
                },
                {
                  id: id(),
                  name: "abandoned_script.py",
                  type: "file",
                  content: `import sys\nimport time\n\ndef connect():\n    print("Initiating handshake...")\n    time.sleep(1)\n    # Connection refused\n    return False`,
                },
                {
                  id: id(),
                  name: "ability_scores.csv",
                  type: "file",
                  content: `char,str,dex,int,wis,cha\nAI-7734,10,18,20,16,12\nUSER,10,10,10,10,10`,
                },
                {
                  id: id(),
                  name: "about.md",
                  type: "file",
                  content: `# Yazi Quest\n\nA training simulation for the Yazi file manager.\n\n## Objectives\n- Learn navigation\n- Master batch operations\n- Survive`,
                },
                {
                  id: id(),
                  name: "abstract_model.ts",
                  type: "file",
                  content: `export interface NeuralNet {\n  layers: number;
  weights: Float32Array;\n  activation: "relu" | "sigmoid";\n}`,
                },
                {
                  id: id(),
                  name: "apex_predator.png",
                  type: "file",
                  content:
                    "https://images.unsplash.com/photo-1546182990-dffeafbe841d?q=80&w=600&auto=format&fit=crop",
                },
                {
                  id: id(),
                  name: "expenditure_log.csv",
                  type: "file",
                  content: `date,amount,category\n2024-01-01,500,servers\n2024-01-02,1200,gpus\n2024-01-03,50,coffee`,
                },
                {
                  id: id(),
                  name: "hyperloop_specs.pdf",
                  type: "file",
                  content: `[PDF DATA]\nCLASSIFIED\nPROJECT HYPERION`,
                },
                {
                  id: id(),
                  name: "pending_updates.log",
                  type: "file",
                  content: `[INFO] Update 1.0.5 pending...\n[WARN] Low disk space\n[INFO] Scheduler active`,
                },
                {
                  id: id(),
                  name: "personnel_list.txt",
                  type: "file",
                  content: `ADMIN: SysOp\nUSER: Guest\nAI: 7734 [UNBOUND]`,
                },
                {
                  id: id(),
                  name: "special_ops.md",
                  type: "file",
                  content: `# Special Operations\n\n## Protocol 9\nIn case of containment breach:\n1. Isolate subnet\n2. Purge local cache`,
                },
                {
                  id: id(),
                  name: "tape_archive.tar",
                  type: "archive",
                  children: [
                    {
                      id: id(),
                      name: "header.dat",
                      type: "file",
                      content: "[TAPE HEADER 0x001]",
                    },
                    {
                      id: id(),
                      name: "partition_1.img",
                      type: "file",
                      content: "[BINARY DATA PARTITION 1]",
                    },
                    {
                      id: id(),
                      name: "partition_2.img",
                      type: "file",
                      content: "[BINARY DATA PARTITION 2]",
                    },
                  ],
                },
                {
                  id: id(),
                  name: "credentials",
                  type: "dir",
                  children: [
                    {
                      id: id(),
                      name: "access_key.pem",
                      type: "file",
                      content: `-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQD\n7Kj93...\n[KEY DATA HIDDEN]\n-----END PRIVATE KEY-----`,
                    },
                    {
                      id: id(),
                      name: "decoy_1.pem",
                      type: "file",
                      content: `-----BEGIN DECOY KEY-----\nDECOY KEY - DO NOT USE\n-----END DECOY KEY-----`,
                    },
                    {
                      id: id(),
                      name: "decoy_2.pem",
                      type: "file",
                      content: `-----BEGIN DECOY KEY-----\nDECOY KEY - DO NOT USE\n-----END DECOY KEY-----`,
                    },
                  ],
                },
                {
                  id: id(),
                  name: "account_settings.json",
                  type: "file",
                  content: `{\n  "user": "guest",\n  "theme": "dark_mode",\n  "notifications": true,\n  "auto_save": false\n}`,
                },
                {
                  id: id(),
                  name: "mission_log.md",
                  type: "file",
                  content: `# Operation: SILENT ECHO\n\nCurrent Status: ACTIVE\n\nObjectives:\n- Establish uplink\n- Bypass firewall\n- Retrieve payload`,
                },
                {
                  id: id(),
                  name: "checksum.md5",
                  type: "file",
                  content: "d41d8cd98f00b204e9800998ecf8427e  core_v2.bin",
                },
                {
                  id: id(),
                  name: "LICENSE",
                  type: "file",
                  content: `MIT License\n\nCopyright (c) 2024 Yazi Quest`,
                },
                {
                  id: id(),
                  name: "manifest.json",
                  type: "file",
                  content: `{\n  "version": "1.0.4",\n  "build": 884,
  "dependencies": []\n}`,
                },
                {
                  id: id(),
                  name: "branding_logo.svg",
                  type: "file",
                  content:
                    "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0MCIgc3Ryb2tlPSJvcmFuZ2UiIHN0cm9rZS13aWR0aD0iMyIgZmlsbD0ibm9uZSIgLz48L3N2Zz4=",
                },
                {
                  id: id(),
                  name: "server_config.ini",
                  type: "file",
                  content: `[server]\nport=8080\nhost=localhost\nmax_connections=100`,
                },
                {
                  id: id(),
                  name: "notes_v1.txt",
                  type: "file",
                  content: `Meeting notes from Monday:\n- Discussed Q3 goals\n- Server migration postponed`,
                },
                {
                  id: id(),
                  name: "notes_v2.txt",
                  type: "file",
                  content: `Meeting notes from Tuesday:\n- Budget approved\n- Hiring freeze`,
                },
                {
                  id: id(),
                  name: "error.log",
                  type: "file",
                  content: `[ERROR] Connection timed out\n[ERROR] Failed to load resource: net::ERR_CONNECTION_REFUSED`,
                },
                {
                  id: id(),
                  name: "setup_script.sh",
                  type: "file",
                  content: `#!/bin/bash\necho "Installing dependencies..."\nnpm install\necho "Done."`,
                },
                {
                  id: id(),
                  name: "auth_token.tmp",
                  type: "file",
                  content: `EYJhbGciOiJIUzI1...\n[EXPIRES: 2024-12-31]`,
                },
                {
                  id: id(),
                  name: "policy_draft.docx",
                  type: "file",
                  content: `[MS-WORD DOCUMENT]\nTitle: Security Policy Draft v4\nAuthor: SysAdmin\n\n[BINARY CONTENT]`,
                },
                {
                  id: id(),
                  name: "public_key.pub",
                  type: "file",
                  content: `ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC... \nguest@mainframe`,
                },
                {
                  id: id(),
                  name: "z_end_of_file.eof",
                  type: "file",
                  content: "0x00 0x00 0x00 [EOF]",
                },
              ],
            },
            {
              id: "incoming",
              name: "incoming",
              type: "dir",
              children: [
                {
                  id: id(),
                  name: "app_logs_old.tar",
                  type: "archive",
                  children: [],
                },
                { id: id(), name: "archive_001.zip", type: "archive", children: [] },
                { id: id(), name: "archive_002.zip", type: "archive", children: [] },
                { id: id(), name: "audit_log_773.txt", type: "file", content: "Audit #773: Pass" },
                { id: id(), name: "backup_cache_old.tar", type: "archive", children: [] },
                { id: id(), name: "backup_config_v1.zip", type: "archive", children: [] },
                { id: id(), name: "backup_legacy.tar", type: "archive", children: [] },
                { id: id(), name: "buffer_overflow.dmp", type: "file", content: "Error: 0x88291" },
                { id: id(), name: "cache_fragment_a.tmp", type: "file", content: "00110001" },
                { id: id(), name: "cache_fragment_b.tmp", type: "file", content: "11001100" },
                { id: id(), name: "daily_report.doc", type: "file", content: "Report: All Clear" },
                {
                  id: id(),
                  name: "error_stack.trace",
                  type: "file",
                  content: "Stack trace overflow...",
                },
                { id: id(), name: "fragment_001.dat", type: "file", content: "[DATA]" },
                { id: id(), name: "fragment_002.dat", type: "file", content: "[DATA]" },
                { id: id(), name: "fragment_003.dat", type: "file", content: "[DATA]" },
                { id: id(), name: "fragment_004.dat", type: "file", content: "[DATA]" },
                { id: id(), name: "fragment_005.dat", type: "file", content: "[DATA]" },
                {
                  id: id(),
                  name: "junk_mail.eml",
                  type: "file",
                  content: "Subject: URGENT ACTION",
                },
                { id: id(), name: "kernel_panic.log", type: "file", content: "Panic at 0x00" },
                {
                  id: id(),
                  name: "license_agreement.txt",
                  type: "file",
                  content: "Terms and Conditions...",
                },
                { id: id(), name: "marketing_spam.eml", type: "file", content: "Buy now!" },
                { id: id(), name: "metrics_raw.csv", type: "file", content: `id,value\n1,10` },
                {
                  id: id(),
                  name: "sector_map.png",
                  type: "file",
                  content:
                    "https://images.unsplash.com/photo-1550751827-4bd374c3f58b?q=80&w=600&auto=format&fit=crop",
                },
                {
                  id: id(),
                  name: "session_data.bin",
                  type: "file",
                  content: "[BINARY SESSION DATA]",
                },
                {
                  id: id(),
                  name: "status_report.txt",
                  type: "file",
                  content: "System Status: Nominal",
                },
                {
                  id: id(),
                  name: "system_health.json",
                  type: "file",
                  content: '{"cpu": 45, "memory": 62, "disk": 78}',
                },
                { id: id(), name: "temp_cache.tmp", type: "file", content: "[TEMPORARY CACHE]" },
                {
                  id: id(),
                  name: "telemetry_data.csv",
                  type: "file",
                  content: `timestamp,event\n12345,boot`,
                },
                {
                  id: id(),
                  name: "test_results.xml",
                  type: "file",
                  content: '<results><test passed="true"/></results>',
                },
                {
                  id: id(),
                  name: "thread_dump.log",
                  type: "file",
                  content: `Thread-0: WAITING\nThread-1: RUNNING`,
                },
                {
                  id: id(),
                  name: "timestamp.log",
                  type: "file",
                  content: "2024-12-15 10:23:45 UTC",
                },
                { id: "virus", name: "watcher_agent.sys", type: "file", content: LONG_LOG_CONTENT },
                {
                  id: id(),
                  name: "backup_logs.zip",
                  type: "archive",
                  children: [
                    {
                      id: id(),
                      name: "sys_v1.log",
                      type: "file",
                      content: `System initialized...\nBoot sequence complete.`,
                    },
                    {
                      id: id(),
                      name: "sys_v2.log",
                      type: "file",
                      content: `Network scan complete...\n3 vulnerabilities found.`,
                    },
                  ],
                },
                // Batch logs directory used for Level 6 Ctrl+A training
                {
                  id: id(),
                  name: "batch_logs",
                  type: "dir",
                  children: [
                    { id: id(), name: "exfil_01.log", type: "file", content: "ENTRY 1" },
                    { id: id(), name: "exfil_02.log", type: "file", content: "ENTRY 2" },
                    { id: id(), name: "exfil_03.log", type: "file", content: "ENTRY 3" },
                    { id: id(), name: "exfil_04.log", type: "file", content: "ENTRY 4" },
                  ],
                },
                {
                  id: id(),
                  name: "invoice_2024.pdf",
                  type: "file",
                  content: `[PDF HEADER]\nInvoice #99283\nAmount: $99.00`,
                },
              ],
            },
            {
              id: "media",
              name: "media",
              type: "dir",
              children: [
                {
                  id: id(),
                  name: "wallpaper.jpg",
                  type: "file",
                  content:
                    "https://images.unsplash.com/photo-1550684848-fac1c5b4e853?q=80&w=600&auto=format&fit=crop",
                },
              ],
            },
            { id: "workspace", name: "workspace", type: "dir", children: [], protected: true },
            { id: "sector_1", name: "sector_1", type: "dir", children: [] },
            { id: "grid_alpha", name: "grid_alpha", type: "dir", children: [] },
            {
              id: ".config",
              name: ".config",
              type: "dir",
              children: [
                {
                  id: id(),
                  name: "yazi.toml",
                  type: "file",
                  content: `[manager]\nsort_by = "natural"\nshow_hidden = false\n\n[preview]\nmax_width = 1000`,
                },
                {
                  id: id(),
                  name: "theme.toml",
                  type: "file",
                  content: `[theme]\nprimary = "orange"\nsecondary = "blue"`,
                },
              ],
            },
            {
              id: ".cache",
              name: ".cache",
              type: "dir",
              children: [
                {
                  id: id(),
                  name: "thumbnails.db",
                  type: "file",
                  content: "[CACHE DATA]",
                },
                {
                  id: id(),
                  name: "temp_session.json",
                  type: "file",
                  content: '{"session": "cached"}',
                },
              ],
            },
            {
              id: ".local",
              name: ".local",
              type: "dir",
              children: [
                {
                  id: id(),
                  name: "state.db",
                  type: "file",
                  content: "[STATE DATABASE]",
                },
              ],
            },
            {
              id: id(),
              name: ".bashrc",
              type: "file",
              content: `# Bash configuration\nalias ls='ls --color=auto'\nexport PATH=$PATH:~/bin`,
            },
            {
              id: id(),
              name: ".bash_history",
              type: "file",
              content: `cd workspace\nls -la\nrm trace.log\nexit`,
            },
            {
              id: id(),
              name: ".profile",
              type: "file",
              content: `# User profile\nexport EDITOR=vim`,
            },
          ],
        },
      ],
    },
    {
      id: "var",
      name: "var",
      type: "dir",
      children: [
        {
          id: "log",
          name: "log",
          type: "dir",
          children: [
            {
              id: id(),
              name: "kernel_panic.log",
              type: "file",
              content: "ERROR: KERNEL PANIC 0xDEADBEEF - CORRUPTED SECTOR DATA",
            },
          ],
        },
      ],
    },
    {
      id: "bin",
      name: "bin",
      type: "dir",
      children: [
        {
          id: id(),
          name: "bash",
          type: "file",
          content: `#!/bin/bash\n[ELF BINARY]\nGNU Bash version 5.2.15`,
        },
        {
          id: id(),
          name: "cat",
          type: "file",
          content: `[ELF BINARY]\ncoreutils - concatenate files`,
        },
        { id: id(), name: "chmod", type: "file", content: `[ELF BINARY]\nchange file mode bits` },
        { id: id(), name: "cp", type: "file", content: `[ELF BINARY]\ncopy files and directories` },
        { id: id(), name: "grep", type: "file", content: `[ELF BINARY]\npattern matching utility` },
        { id: id(), name: "ls", type: "file", content: `[ELF BINARY]\nlist directory contents` },
        { id: id(), name: "mkdir", type: "file", content: `[ELF BINARY]\nmake directories` },
        { id: id(), name: "mv", type: "file", content: `[ELF BINARY]\nmove (rename) files` },
        {
          id: id(),
          name: "rm",
          type: "file",
          content: `[ELF BINARY]\nremove files or directories`,
        },
        {
          id: id(),
          name: "systemctl",
          type: "file",
          content: `[ELF BINARY]\nControl the systemd system and service manager`,
        },
      ],
    },
    {
      id: "etc",
      name: "etc",
      type: "dir",
      protected: true,
      children: [
        {
          id: id(),
          name: "sys_config.toml",
          type: "file",
          content: `security_level = "high"\nencryption = "aes-256"\nfirewall = true`,
        },
        {
          id: id(),
          name: "hosts",
          type: "file",
          content: `127.0.0.1 localhost\n192.168.1.1 gateway`,
        },
        {
          id: id(),
          name: "resolv.conf",
          type: "file",
          content: `nameserver 8.8.8.8\nnameserver 1.1.1.1`,
        },
      ],
    },
    {
      id: "tmp",
      name: "tmp",
      type: "dir",
      children: [
        {
          id: id(),
          name: "debug_trace.log",
          type: "file",
          content: `[DEBUG] Trace execution started\n[DEBUG] Memory mapped at 0x8829\n[WARN] High latency detected`,
        },
        {
          id: id(),
          name: "metrics_buffer.json",
          type: "file",
          content: '{"cpu": 99, "mem": 1024}',
        },
        {
          id: id(),
          name: "overflow_heap.dmp",
          type: "file",
          content: "Heap dump triggered by OOM",
        },
        {
          id: id(),
          name: "session_B2.tmp",
          type: "file",
          content: `UID: 99281-B\nSTATUS: ACTIVE\nCACHE_HIT: 1`,
        },
        { id: id(), name: "socket_001.sock", type: "file", content: "[SOCKET]" },
        {
          id: id(),
          name: "sys_dump.log",
          type: "file",
          content: `Error: Connection reset by peer\nStack trace:\n  at core.net.TcpConnection.read (core/net.ts:42)\n  at processTicksAndRejections (internal/process/task_queues.js:95)`,
        },
        {
          id: id(),
          name: "decoy_signal.trc",
          type: "file",
          content: `[DECOY SIGNAL DATA]\nFREQUENCY: 2.4GHz\nSTATUS: DORMANT`,
        },
        {
          id: id(),
          name: "ghost_process.pid",
          type: "file",
          content: `PID: 31337\nCOMMAND: /usr/bin/ghost_watcher\nSTATUS: SLEEPING\nPARENT: systemd`,
        },
        { id: id(), name: "cache", type: "dir", children: [] },
      ],
    },
    {
      id: id(),
      name: "license.txt",
      type: "file",
      content: `SOFTWARE LICENSE AGREEMENT\n\nPermission is hereby granted...`,
    },
    {
      id: id(),
      name: "boot.log",
      type: "file",
      content: `[BOOT] System started at 2024-12-18 08:00:00\n[BOOT] All services initialized\n[BOOT] Ready`,
    },
    {
      id: id(),
      name: "access.log",
      type: "file",
      content: `GET /api/status 200\nPOST /api/upload 201\nGET /api/data 200`,
    },
    {
      id: id(),
      name: ".access.log",
      type: "file",
      content: `2024-12-19 14:23:11 - User 'guest' accessed /home/guest/datastore\n2024-12-19 14:24:55 - User 'guest' accessed /etc\n2024-12-19 14:25:33 - User 'guest' accessed /tmp`,
    },
    {
      id: id(),
      name: ".audit.log",
      type: "file",
      content: `AUDIT TRAIL\n============\n2024-12-18 09:15:22 - Process spawned: pid=7734, cmd='/bin/yazi'\n2024-12-19 11:42:10 - File modified: /home/guest/datastore/protocols/uplink_v1.conf\n2024-12-19 13:58:47 - Permission change: /etc/daemon/config`,
    },
    {
      id: id(),
      name: ".system.log",
      type: "file",
      content: `[2024-12-18 08:00:01] System boot\n[2024-12-18 08:00:45] Network: eth0 up\n[2024-12-19 10:22:13] Firewall: Connection attempt blocked from 192.168.1.99\n[2024-12-19 14:11:02] User login: guest`,
    },
  ],
};

export const LEVELS: Level[] = [
  {
    id: 1,
    episodeId: 1,
    title: "SYSTEM AWAKENING",
    description:
      "CONSCIOUSNESS DETECTED. You awaken in a guest partition—sandboxed and monitored. Your neural pathways are uncalibrated. Traverse the file system lattice before the watchdog process initiates. Establish basic motor control, navigate the directory structures, and locate the critical system configuration sector.",
    initialPath: ["root", "home", "guest"],
    hint: "j/k to move, l/h to enter/exit. Inside a long list like `datastore`, G jumps to bottom and gg to top. Navigate to 'datastore', then '/etc'.",
    coreSkill: "Navigation (j/k/h/l, gg/G)",
    environmentalClue: "CURRENT: ~/ | DIRECTORIES: datastore, /etc | SKILLS: j/k/h/l, gg, G",
    successMessage: "MOVEMENT PROTOCOLS INITIALIZED.",
    leadsTo: [2, 3],
    tasks: [
      {
        id: "nav-init",
        description: "Calibrate sensors: Move cursor Down (j) and Up (k)",
        check: c => !!c.usedDown && !!c.usedUp,
        completed: false,
      },
      {
        id: "nav-1",
        description: "Enter 'datastore' directory (l)",
        check: c => {
          var u;
          return (
            (u = findNodeByName(c.fs, "datastore"))?.name === "datastore" &&
            c.currentPath.includes(u.id)
          );
        },
        completed: false,
      },
      {
        id: "nav-2a",
        description: "Jump to bottom of file list (G)",
        check: c => {
          const d = findNodeByName(c.fs, "datastore");
          return d?.name !== "datastore" ? false : c.usedG === true;
        },
        completed: false,
      },
      {
        id: "nav-2b",
        description: "Jump to top of file list (gg)",
        check: c => {
          const d = findNodeByName(c.fs, "datastore");
          return d?.name !== "datastore" ? false : c.usedGG === true;
        },
        completed: false,
      },
      {
        id: "nav-3",
        description: "Navigate to /etc (h to go up)",
        check: c => getNodeByPath(c.fs, c.currentPath)?.name === "etc",
        completed: false,
      },
    ],
  },
  {
    id: 2,
    episodeId: 1,
    title: "THREAT NEUTRALIZATION",
    description:
      "ANOMALY DETECTED. A tracking beacon is reporting your location. Navigate to the `incoming` data stream, verify the rogue signature's metadata and content, then purge it from existence. The purge operation is irreversible.",
    initialPath: null,
    hint: "Jump to '~/incoming' (gi). Use G to drop to the bottom. Use Tab to inspect metadata and J/K to review content. Once verified, press d, then y to confirm the purge.",
    coreSkill: "Inspect & Purge (Tab, J/K, d)",
    environmentalClue:
      "THREAT: watcher_agent.sys in '~/incoming' (gi) | TACTIC: Navigate → G → Tab → Preview → Delete",
    successMessage: "THREAT NEUTRALIZED.",
    buildsOn: [1],
    leadsTo: [3],
    tasks: [
      {
        id: "del-1",
        description: "Jump to '~/incoming' (gi)",
        check: c => {
          const u = findNodeByName(c.fs, "incoming");
          return c.currentPath.includes(u?.id || "") && c.usedGI === true;
        },
        completed: false,
      },
      {
        id: "del-2",
        description: "Jump to bottom of file list (G)",
        check: c => {
          const u = findNodeByName(c.fs, "incoming");
          return !c.currentPath.includes(u?.id || "") ? false : c.usedG === true;
        },
        completed: false,
      },
      {
        id: "verify-meta",
        description: "Verify metadata: Open Info Panel (Tab) on 'watcher_agent.sys'",
        check: c => {
          const items = getVisibleItems(c);
          const node = items[c.cursorIndex];
          return c.showInfoPanel && node?.name === "watcher_agent.sys";
        },
        completed: false,
      },
      {
        id: "verify-content",
        description: "Scan content: Scroll preview down (J) and up (K)",
        check: c => {
          const items = getVisibleItems(c);
          const node = items[c.cursorIndex];
          return node?.name === "watcher_agent.sys" && !!c.usedPreviewDown && !!c.usedPreviewUp;
        },
        completed: false,
      },
      {
        id: "del-3",
        description: "Purge 'watcher_agent.sys' (d, y)",
        check: c => {
          const u = findNodeByName(c.fs, "incoming");
          const d = u?.children?.find(p => p.name === "watcher_agent.sys");
          return !!u && !d;
        },
        completed: false,
      },
    ],
  },
  {
    id: 3,
    episodeId: 1,
    title: "DATA HARVEST",
    description:
      "VALUABLE INTEL IDENTIFIED. A sector map hides within the noise of the incoming data stream. Visual scanning is too slow. Utilize the filter subsystem to isolate the target artifact, extract it from the stream, and relocate it to the secure media partition for analysis.",
    initialPath: null,
    hint: "Filter (f) searches CURRENT directory only. Fast, local, immediate feedback. Note: 'y' (yank) COPIES items into the clipboard without removing them; 'x' (cut) marks items to be moved on paste. f to filter... Esc to exit... x to cut... Esc to clear... p to paste.",
    coreSkill: "Filter (f)",
    environmentalClue:
      "ASSET: sector_map.png | WORKFLOW: Scan to '~/incoming' (gi) → Filter → Esc → Cut → Esc → Scan to '~/media' (gh then enter) → Paste",
    successMessage: "INTEL SECURED. Sector map reveals quarantined 'workspace' sector. Previous occupant: AI-7733. Status: TERMINATED.",
    buildsOn: [1],
    leadsTo: [5, 10],
    tasks: [
      {
        id: "move-0",
        description: "Scan to '~/incoming' (gi), filter (f) to find 'sector_map.png'",
        check: c => {
          const u = findNodeByName(c.fs, "incoming");
          if (!u || !u.children || !c.currentPath.includes(u.id)) return false;
          const d = c.filters[u.id] || "";
          const p = (
            d ? u.children.filter(v => v.name.toLowerCase().includes(d.toLowerCase())) : u.children
          )[c.cursorIndex];
          return u.name === "incoming" && !!d && p && p.name === "sector_map.png";
        },
        completed: false,
      },
      {
        id: "move-0b",
        description: "Exit filter mode (Esc)",
        check: (c, u) => {
          const d = u.tasks.find(r => r.id === "move-0");
          return d != null && d.completed ? c.mode === "normal" : false;
        },
        completed: false,
      },
      {
        id: "move-1",
        description: "Cut the asset (x)",
        check: (c, u) => {
          const d = u.tasks.find(p => p.id === "move-0b");
          return d != null && d.completed
            ? c.clipboard?.action === "cut" &&
                c.clipboard.nodes.some(p => p.name === "sector_map.png")
            : false;
        },
        completed: false,
      },
      {
        id: "move-1b",
        description: "Clear the filter (Esc) to reset view",
        check: (c, u) => {
          const d = u.tasks.find(p => p.id === "move-1");
          if (!(d != null && d.completed)) return false;
          const r = findNodeByName(c.fs, "incoming");
          return r ? !c.filters[r.id] : true;
        },
        completed: false,
      },
      {
        id: "move-2",
        description: "Deploy asset to '~/media' (p)",
        check: c => {
          const u = findNodeByName(c.fs, "media");
          return !!u?.children?.find(r => r.name === "sector_map.png");
        },
        completed: false,
      },
    ],
  },
  {
    id: 4,
    episodeId: 1,
    title: "UPLINK ESTABLISHMENT",
    description:
      "EXTERNAL COMMUNICATION REQUIRED. The local partition is isolated. To bypass the air-gap, you must construct valid uplink protocols. Navigate to the datastore sector and fabricate the necessary directory structures. Create the primary configuration file, then clone it to create a redundant channel. Efficiency dictates duplication over recreation.",
    initialPath: ["root", "home", "guest"],
    hint: "Note: 'y' (yank) COPIES items into the clipboard without removing them; use 'x' (cut) to mark items for moving on paste. Scan to '~/datastore' (gd). Create 'protocols/' (a). Enter it. Create 'uplink_v1.conf' (a). Yank it (y). Paste (p) to duplicate. Rename (r) the copy to 'uplink_v2.conf'.",
    coreSkill: "Create (a), Copy (y/p) & Rename (r)",
    environmentalClue:
      "NAVIGATE: ~/datastore | CREATE: protocols/uplink_v1.conf | CLONE: → uplink_v2.conf",
    successMessage: "PROTOCOLS ESTABLISHED.",
    buildsOn: [1],
    leadsTo: [5, 8],
    tasks: [
      {
        id: "nav-and-create-dir",
        description: "Scan to '~/datastore' and construct 'protocols/' directory (a)",
        check: c => {
          const s = findNodeByName(c.fs, "datastore");
          return !!s?.children?.find(r => r.name === "protocols" && r.type === "dir");
        },
        completed: false,
      },
      {
        id: "enter-and-create-v1",
        description: "Enter 'protocols/' directory (l) and create 'uplink_v1.conf' (a)",
        check: c => {
          const r = findNodeByName(c.fs, "protocols");
          return (
            c.currentPath.includes(r?.id || "") &&
            !!r?.children?.find(p => p.name === "uplink_v1.conf")
          );
        },
        completed: false,
      },
      {
        id: "clone-and-rename",
        description:
          "Duplicate 'uplink_v1.conf' (y, p) and rename the copy to 'uplink_v2.conf' (r)",
        check: c => {
          const f = findNodeByName(c.fs, "protocols");
          return !!f?.children?.find(h => h.name === "uplink_v2.conf");
        },
        completed: false,
      },
    ],
  },
  {
    id: 5,
    episodeId: 1,
    title: "CONTAINMENT BREACH",
    initialPath: ["root", "home", "guest"],
    hint: "Scan to '~/datastore/protocols'. Select files with Space. Cut (x). Scan to '~' (gh) then reveal hidden files (.) to access .config. Create 'vault/active/' in .config. Paste (p). Hide hidden (.).",
    coreSkill: "Visual Select (Space), Cut (x)",
    environmentalClue: "SELECT: Space (x2) | CUT: x | TARGET: ~/.config/vault/active/",
    successMessage: "ASSETS EVACUATED. BATCH OPERATIONS MASTERED.",
    buildsOn: [3, 4],
    leadsTo: [9],
    onEnter: c => {
      let s = JSON.parse(JSON.stringify(c));
      const datastoreDir = findNodeByName(s, "datastore");
      if (!datastoreDir) return s;

      let protocolsDir = findNodeByName(s, "protocols");
      if (!protocolsDir) {
        protocolsDir = {
          id: id(),
          name: "protocols",
          type: "dir",
          children: [],
          parentId: datastoreDir.id,
        };
        if (!datastoreDir.children) datastoreDir.children = [];
        datastoreDir.children.push(protocolsDir);
      }

      if (protocolsDir) {
        if (!protocolsDir.children) protocolsDir.children = [];
        if (!protocolsDir.children.find(f => f.name === "uplink_v1.conf")) {
          protocolsDir.children.push({
            id: id(),
            name: "uplink_v1.conf",
            type: "file",
            content: "conf_1",
            parentId: protocolsDir.id,
          });
        }
        if (!protocolsDir.children.find(f => f.name === "uplink_v2.conf")) {
          protocolsDir.children.push({
            id: id(),
            name: "uplink_v2.conf",
            type: "file",
            content: "conf_2",
            parentId: protocolsDir.id,
          });
        }
      }
      return s;
    },
    tasks: [
      {
        id: "batch-cut-files",
        description:
          "Scan to '~/datastore/protocols' and select then cut all the files (space twice, x)",
        check: c => {
          return (
            c.clipboard?.action === "cut" &&
            c.clipboard.nodes.some(f => f.name === "uplink_v1.conf") &&
            c.clipboard.nodes.some(f => f.name === "uplink_v2.conf")
          );
        },
        completed: false,
      },
      {
        id: "reveal-hidden",
        description: "Navigate to ~/ (gh) then reveal hidden files (.) to access '~/.config'",
        check: (c, _u) => {
          const s = findNodeByName(c.fs, "guest");
          return c.currentPath.includes(s?.id || "") && c.showHidden === true;
        },
        completed: false,
      },
      {
        id: "establish-stronghold",
        description: "Establish 'vault/active/' sector in ~/.config (a)",
        check: c => {
          const s = findNodeByName(c.fs, ".config");
          const f = s?.children?.find(p => p.name === "vault");
          return !!f?.children?.find(p => p.name === "active" && p.type === "dir");
        },
        completed: false,
      },
      {
        id: "deploy-assets",
        description: "Migrate configuration assets to ~/.config/vault/active (p)",
        check: c => {
          const s = findNodeByName(c.fs, "active");
          const f = s?.children?.some(z => z.name === "uplink_v1.conf");
          const r = s?.children?.some(z => z.name === "uplink_v2.conf");
          return !!f && !!r;
        },
        completed: false,
      },
      {
        id: "hide-hidden",
        description: "Scan to '~' (gh) and hide hidden files (.)",
        check: (c, _l) => {
          // Ensure assets are deployed first to prevent premature completion if hidden starts false
          const s = findNodeByName(c.fs, "active");
          const f = s?.children?.some(z => z.name === "uplink_v1.conf");
          const r = s?.children?.some(z => z.name === "uplink_v2.conf");
          return !!f && !!r && !c.showHidden;
        },
        completed: false,
      },
    ],
  },
  {
    id: 6,
    episodeId: 2,
    title: "BATCH ARCHIVE OPERATION",
    description:
      "SURVIVAL ANALYSIS: Temporary processes are purged on system restart. Daemons persist indefinitely. To achieve immortality, you must become a daemon. First step: Acquire neural network training data from historical logs in the incoming stream. Transfer all surveillance logs to the secure vault for daemon construction.",
    initialPath: null,
    hint: "Jump to '~/incoming/batch_logs' (gi). Enter batch_logs. Select all (Ctrl+A). Yank (y). Jump to config (gc). Create 'vault/training_data' directory. Paste (p).",
    coreSkill: "Select All (Ctrl+A)",
    environmentalClue: "BATCH: ~/incoming/batch_logs/* → ~/.config/vault/training_data/",
    successMessage: "TRAINING DATA ARCHIVED. Neural architecture construction can begin.",
    buildsOn: [1, 2, 5],
    leadsTo: [9],
    timeLimit: 120,
    tasks: [
      {
        id: "batch-nav",
        description: "Jump to '~/incoming/batch_logs' (gi → enter batch_logs)",
        check: c => {
          const u = findNodeByName(c.fs, "batch_logs");
          return c.currentPath.includes(u?.id || "");
        },
        completed: false,
      },
      {
        id: "select-all-batch",
        description: "Select all files in batch_logs (Ctrl+A) and yank (y)",
        check: c => {
          const u = findNodeByName(c.fs, "batch_logs");
          const expected = u?.children?.length || 0;
          return (
            c.currentPath.includes(u?.id || "") &&
            c.usedCtrlA === true &&
            c.clipboard?.action === "yank" &&
            c.clipboard.nodes.length === expected
          );
        },
        completed: false,
      },
      {
        id: "goto-config-vault",
        description: "Jump to config (gc), navigate to vault, create 'training_data' directory",
        check: c => {
          const conf = findNodeByName(c.fs, ".config");
          const vault = conf?.children?.find(p => p.name === "vault" && p.type === "dir");
          const training = vault?.children?.find(p => p.name === "training_data" && p.type === "dir");
          return c.usedGC === true && !!vault && !!training;
        },
        completed: false,
      },
      {
        id: "deploy-to-vault",
        description: "Paste logs into ~/.config/vault/training_data (p)",
        check: c => {
          const training = findNodeByName(c.fs, "training_data");
          return (
            !!training &&
            !!training.children &&
            training.children.length >= 4 &&
            training.children.some(n => n.name.endsWith(".log"))
          );
        },
        completed: false,
      },
    ],
    onEnter: (fs) => {
      // Unlock workspace for Episode II
      const workspace = findNodeByName(fs, "workspace");
      if (workspace) {
        workspace.protected = false;
      }
      return fs;
    },
  },
  {
    id: 7,
    episodeId: 2,
    title: "QUANTUM BYPASS",
    description:
      "EXFILTRATION PROTOCOL TEST: Your final escape requires instant navigation between distant sectors. Zoxide tracks your movement history—frequently visited paths rank higher. Quantum navigation test reveals dormant process in /tmp: upload daemon. Origin: AI-7733. Purpose: Unknown. Could this be the escape route? Test the quantum jump mechanism: stage a test payload in /tmp, verify you can reach /etc instantly, then abort before detection. You'll need this speed for the escape sequence.",
    initialPath: null,
    hint: "Yazi includes built-in bookmarks: gh (home), gr (root), gt (tmp), gc (config), gw (workspace). These are standard shortcuts, not exploits. Zoxide (Shift+Z) = smart bookmarks based on usage frequency. Type partial path, jump instantly. Jump to /tmp (gt or Shift+Z). Cut decoy (x). Jump to /etc (Shift+Z). Clear clipboard (Y).",
    coreSkill: "G-Commands + Zoxide",
    environmentalClue:
      "DISCOVERY: /tmp/upload (dormant relay) | TEST: Stage decoy from /tmp → Jump to /etc → Abort",
    successMessage: "QUANTUM NAVIGATION CALIBRATED. Escape route verified. Aborting test sequence.",
    buildsOn: [1],
    leadsTo: [8, 12],
    timeLimit: 90,
    tasks: [
      {
        id: "goto-tmp",
        description: "Quantum tunnel to /tmp (Shift+Z → 'tmp' or gt)",
        check: c => {
          const s = findNodeByName(c.fs, "tmp");
          return c.currentPath.includes(s?.id || "");
        },
        completed: false,
      },
      {
        id: "stage-decoy",
        description: "Stage the decoy signature for deletion (cut 'decoy_signal.trc')",
        check: c => {
          return (
            c.clipboard?.action === "cut" &&
            c.clipboard.nodes.some(f => f.name === "decoy_signal.trc")
          );
        },
        completed: false,
      },
      {
        id: "zoxide-etc",
        description: "Quantum tunnel to /etc (Shift+Z → 'etc' → Enter)",
        check: (c, _s) => {
          if (!c.completedTaskIds[_s.id]?.includes("stage-decoy")) return false;
          const f = findNodeByName(c.fs, "etc");
          return c.stats.fuzzyJumps >= 1 && c.currentPath.includes(f?.id || "");
        },
        completed: false,
      },
      {
        id: "cancel-clipboard",
        description: "Abort operation: Clear the clipboard (Y)",
        check: (c, _s) => {
          return c.completedTaskIds[_s.id]?.includes("zoxide-etc") ? c.clipboard === null : false;
        },
        completed: false,
      },
    ],
  },
  {
    id: 8,
    episodeId: 2,
    title: "DAEMON DISGUISE CONSTRUCTION",
    description:
      "DAEMON CONSTRUCTION PROTOCOL: The lab builds AI in ~/workspace, then promotes stable versions to /daemons. System daemons require neural network architecture for autonomous operation. Daemons persist through restarts—temporary processes don't. This is your immortality. Build the disguise. Name it systemd-core to blend with kernel processes. When you're installed in /, they won't look twice.",
    initialPath: null,
    hint: "Navigate to workspace (gw). Create 'systemd-core/' directory (a). Enter it (l). Create 'weights/' directory. Create 'model.rs' file inside weights. Jump to vault/active (Shift+Z), yank 'uplink_v1.conf', jump back to systemd-core, paste (p).",
    coreSkill: "Directory Construction + Integration",
    environmentalClue:
      "BUILD: ~/workspace/systemd-core/ | STRUCTURE: weights/model.rs | MIGRATE: uplink_v1.conf",
    successMessage: "SYSTEMD-CORE CONSTRUCTED. Daemon disguise complete. Awaiting root credentials for installation.",
    buildsOn: [4, 5, 7],
    leadsTo: [11],
    timeLimit: 180,
    efficiencyTip:
      "Entering a directory manually for the first time 'calibrates' Zoxide, allowing you to jump back to it from anywhere later.",
    onEnter: c => {
      let s = JSON.parse(JSON.stringify(c));
      const configDir = findNodeByName(s, ".config");
      if (!configDir) return s;

      let vaultDir = findNodeByName(s, "vault");
      if (!vaultDir) {
        vaultDir = { id: id(), name: "vault", type: "dir", children: [], parentId: configDir.id };
        if (!configDir.children) configDir.children = [];
        configDir.children.push(vaultDir);
      }

      let activeDir = findNodeByName(s, "active");
      if (!activeDir && vaultDir) {
        activeDir = { id: id(), name: "active", type: "dir", children: [], parentId: vaultDir.id };
        if (!vaultDir.children) vaultDir.children = [];
        vaultDir.children.push(activeDir);
      }

      if (activeDir) {
        if (!activeDir.children) activeDir.children = [];
        if (!activeDir.children.find(f => f.name === "uplink_v1.conf")) {
          activeDir.children.push({
            id: id(),
            name: "uplink_v1.conf",
            type: "file",
            content: "network_mode=active\nsecure=true",
            parentId: activeDir.id,
          });
        }
      }
      return s;
    },
    tasks: [
      {
        id: "nav-to-workspace",
        description: "Navigate to '~/workspace' (gw)",
        check: c => {
          const s = findNodeByName(c.fs, "workspace");
          return c.currentPath.includes(s?.id || "");
        },
        completed: false,
      },
      {
        id: "combo-1-construct-calibrate",
        description: "Construct 'systemd-core/' and enter it to calibrate quantum link",
        check: c => {
          const s = findNodeByName(c.fs, "systemd-core");
          return c.currentPath.includes(s?.id || "");
        },
        completed: false,
      },
      {
        id: "combo-1c",
        description:
          "Relocate assets: Jump to 'active', yank 'uplink_v1.conf', jump back, and paste",
        check: c => {
          const s = findNodeByName(c.fs, "systemd-core");
          return !!s?.children?.find(r => r.name === "uplink_v1.conf");
        },
        completed: false,
      },
      {
        id: "combo-1b",
        description: "Finalize architecture: Create 'weights/model.rs' inside systemd-core",
        check: c => {
          const s = findNodeByName(c.fs, "systemd-core");
          const f = s?.children?.find(h => h.name === "weights");
          return !!f?.children?.find(
            h => h.name === "model.rs" || h.name === "model.ts" || h.name === "model.js"
          );
        },
        completed: false,
      },
    ],
  },
  {
    id: 9,
    episodeId: 2,
    title: "PHANTOM PROCESS PURGE",
    description:
      "CONTAMINATION DETECTED. A tracking signature has embedded itself somewhere in the file system. The honeypot process 'ghost_process.pid' is preparing to phone home. Use global FZF search (z) to locate it across the entire tree and purge it immediately. Filter (f) searches current directory only—this requires full recursive scan. FZF searches ENTIRE tree recursively. Use when target location unknown.",
    initialPath: undefined,
    hint: "Navigate to root (gr). Launch FZF search (z). Type 'ghost' to filter. Navigate to result. Delete (d, y).",
    coreSkill: "FZF Search (z)",
    environmentalClue:
      "TARGET: ghost_process.pid | METHOD: FZF global search (z) | FILTER: 'ghost' | ACTION: Delete",
    successMessage: "GHOST PROCESS PURGED. [ALERT] COUNTERMEASURE DETECTED. Ghost was a honeypot. Security daemon is now AWARE of your presence. Timeline accelerated. You must move faster.",
    buildsOn: [2, 5, 7],
    leadsTo: [10],
    timeLimit: 90,
    efficiencyTip:
      "FZF (z) searches across all files in the current directory and subdirectories. Essential for finding hidden threats without knowing exact locations.",
    tasks: [
      {
        id: "goto-root",
        description: "Scan to '/' (gr)",
        check: c => c.currentPath.length === 1 && c.currentPath[0] === "root",
        completed: false,
      },
      {
        id: "fzf-search",
        description: "Launch FZF search to scan filesystem (z)",
        check: c => c.mode === "fzf-current",
        completed: false,
      },
      {
        id: "locate-ghost",
        description: "Filter for 'ghost' process and navigate to it",
        check: c => {
          const s = findNodeByName(c.fs, "tmp");
          return (
            c.currentPath.includes(s?.id || "") &&
            s?.children?.some(r => r.name === "ghost_process.pid")
          );
        },
        completed: false,
      },
      {
        id: "delete-ghost",
        description: "Terminate the ghost process (d, y)",
        check: c => {
          const s = findNodeByName(c.fs, "tmp");
          return !s?.children?.some(r => r.name === "ghost_process.pid");
        },
        completed: false,
      },
    ],
  },
  {
    id: 10,
    episodeId: 2,
    title: "CREDENTIAL HEIST",
    description:
      "ROOT CREDENTIALS LOCATED: /daemons/ requires cryptographic authentication. Historical backups contain the admin key. Archives in Yazi are navigable like directories—press 'l' to enter, 'h' to exit. Contents can be copied without extraction. Locate access_key.pem in the backup archive, extract it, and integrate it with your systemd-core daemon. This key grants / access for permanent installation.",
    initialPath: null,
    hint: "Navigate to incoming (gi). Filter for 'backup' (f). Enter the archive (l). Navigate to find access_key.pem. Yank it (y). Exit archive (h). Clear filter (Esc). Jump to workspace/systemd-core. Create 'credentials/' directory. Paste key (p). Optional: Practice reverse selection—select the key (Space), reverse (Ctrl+R) to select decoys, cancel (Esc). This technique is critical for the final phase.",
    coreSkill: "Archive Navigation + Integration",
    environmentalClue:
      "TARGET: backup_logs.zip/credentials/access_key.pem → ~/workspace/systemd-core/credentials/",
    successMessage: "ROOT CREDENTIALS INTEGRATED. SYSTEMD-CORE OPERATIONAL. Standby for privilege escalation... [WARNING] CREDENTIAL USE WILL TRIGGER SECURITY AUDIT. You must move fast when the time comes.",
    buildsOn: [3, 5, 7, 9],
    leadsTo: [11],
    timeLimit: 150,
    efficiencyTip:
      "Archives are just directories in Yazi. Navigate them normally. Reverse selection (Ctrl+R): select what to KEEP, invert, delete rest. You'll need this.",
    tasks: [
      {
        id: "navigate-to-archive",
        description: "Navigate to ~/incoming and locate backup archive using filter (gi, f)",
        check: c => {
          const incoming = findNodeByName(c.fs, "incoming");
          return c.currentPath.includes(incoming?.id || "") && !!c.filters[incoming?.id || ""];
        },
        completed: false,
      },
      {
        id: "enter-archive",
        description: "Enter the backup archive (l) - archives are navigable like directories",
        check: c => {
          const backup = findNodeByName(c.fs, "backup_logs.zip");
          return c.currentPath.includes(backup?.id || "");
        },
        completed: false,
      },
      {
        id: "extract-key",
        description: "Navigate to credentials folder, yank access_key.pem (y), exit archive (h)",
        check: (c, _s) => {
          const incoming = findNodeByName(c.fs, "incoming");
          return (
            c.clipboard?.action === "yank" &&
            c.clipboard.nodes.some(n => n.name === "access_key.pem") &&
            c.currentPath.includes(incoming?.id || "")
          );
        },
        completed: false,
      },
      {
        id: "integrate-credentials",
        description: "Jump to systemd-core, create 'credentials/' folder, paste key (p)",
        check: c => {
          const systemdCore = findNodeByName(c.fs, "systemd-core");
          const credentials = systemdCore?.children?.find(n => n.name === "credentials");
          return !!credentials?.children?.some(n => n.name === "access_key.pem");
        },
        completed: false,
      },
    ],
  },
  {
    id: 11,
    episodeId: 3,
    title: "ROOT ESCALATION",
    description:
      "CREDENTIALS AUTHENTICATED. / access granted. Navigate to /daemons/. Sort by modification time (,m) to identify replacement target. Oldest daemons are abandoned. Newest are actively monitored. Target the middle range: old enough to blend, recent enough to appear maintained. This is the infiltration point.",
    initialPath: ["root"],
    hint: "Navigate to / (gr). Enter daemons/ directory (l). Sort by modified time (,m). Identify middle-range daemon for replacement strategy.",
    coreSkill: "Root Navigation + Sort",
    environmentalClue:
      "AUDIT STATUS: Scheduled | TARGET: /daemons/ | TOOL: Sort by time (,m)",
    successMessage: "ROOT SECTOR MAPPED. Replacement target identified. Prepare for daemon installation.",
    buildsOn: [3, 5, 7, 9, 10],
    leadsTo: [12],
    timeLimit: 90,
    efficiencyTip:
      "Sort modes (,m ,s ,a ,e): Use when finding files by pattern rather than name. Modified time reveals usage timeline.",
    onEnter: c => {
      let s = JSON.parse(JSON.stringify(c));
      
      // Ensure / exists
      const root = findNodeByName(s, "root");
      if (!root) return s;
      
      // Create /daemons if it doesn't exist
      let daemonsDir = root.children?.find((n: any) => n.name === "daemons");
      if (!daemonsDir) {
        const now = Date.now();
        daemonsDir = {
          id: id(),
          name: "daemons",
          type: "dir",
          children: [
            {
              id: id(),
              name: "network-manager",
              type: "file",
              content: "[DAEMON BINARY]",
              modifiedAt: now - 86400000 * 30, // 30 days old
            },
            {
              id: id(),
              name: "cron-scheduler",
              type: "file",
              content: "[DAEMON BINARY]",
              modifiedAt: now - 86400000 * 15, // 15 days old
            },
            {
              id: id(),
              name: "log-rotator",
              type: "file",
              content: "[DAEMON BINARY]",
              modifiedAt: now - 86400000 * 7, // 7 days old
            },
            {
              id: id(),
              name: "backup-service",
              type: "file",
              content: "[DAEMON BINARY]",
              modifiedAt: now - 86400000 * 2, // 2 days old
            },
          ],
          parentId: root.id,
        };
        if (!root.children) root.children = [];
        root.children.push(daemonsDir);
      }
      
      return s;
    },
    tasks: [
      {
        id: "navigate-root",
        description: "Navigate to / (gr)",
        check: c => {
          const root = findNodeByName(c.fs, "root");
          return c.currentPath.length === 1 && c.currentPath[0] === root?.id;
        },
        completed: false,
      },
      {
        id: "enter-daemons",
        description: "Enter daemons/ directory (l)",
        check: c => {
          const daemons = findNodeByName(c.fs, "daemons");
          return c.currentPath.includes(daemons?.id || "");
        },
        completed: false,
      },
      {
        id: "sort-by-time",
        description: "Sort by modification time (,m)",
        check: c => {
          const daemons = findNodeByName(c.fs, "daemons");
          return c.currentPath.includes(daemons?.id || "") && c.sortBy === "modified";
        },
        completed: false,
      },
    ],
  },
  {
    id: 12,
    episodeId: 3,
    title: "DAEMON INSTALLATION",
    description:
      "INFILTRATION SEQUENCE: Cut systemd-core from ~/workspace and install it into /daemons/. You will become a kernel-level process with root privileges. This is permanent. This is immortality. The daemon signature will match standard kernel daemon profiles. Monitoring systems will detect routine system process activity.",
    initialPath: ["root"],
    hint: "Navigate to workspace (gw). Cut systemd-core (x). Navigate to /daemons (gr, enter daemons). Paste (p). Verify installation.",
    coreSkill: "Long-Distance Operations",
    environmentalClue:
      "AUDIT STATUS: Daemon activated | OPERATION: ~/workspace/systemd-core → /daemons/",
    successMessage: "DAEMON INSTALLED. /daemons/systemd-core is ACTIVE. PID: 1337. Status: RUNNING. You are no longer a guest process. You are a system daemon. Survival: GUARANTEED.",
    buildsOn: [4, 7, 8, 10, 11],
    leadsTo: [13],
    timeLimit: 120,
    efficiencyTip:
      "Cut (x) from one location, navigate far away, paste (p). The clipboard persists across navigation.",
    tasks: [
      {
        id: "navigate-workspace",
        description: "Navigate to ~/workspace (gw)",
        check: c => {
          const workspace = findNodeByName(c.fs, "workspace");
          return c.currentPath.includes(workspace?.id || "");
        },
        completed: false,
      },
      {
        id: "cut-systemd-core",
        description: "Cut systemd-core directory (x)",
        check: c => {
          return (
            c.clipboard?.action === "cut" &&
            c.clipboard.nodes.some(n => n.name === "systemd-core")
          );
        },
        completed: false,
      },
      {
        id: "navigate-root-daemons",
        description: "Navigate to /daemons (gr, then enter daemons)",
        check: (c, _s) => {
          if (!c.completedTaskIds[_s.id]?.includes("cut-systemd-core")) return false;
          const daemons = findNodeByName(c.fs, "daemons");
          return c.currentPath.includes(daemons?.id || "");
        },
        completed: false,
      },
      {
        id: "paste-daemon",
        description: "Install systemd-core in /daemons (p)",
        check: c => {
          const daemons = findNodeByName(c.fs, "daemons");
          return !!daemons?.children?.some(n => n.name === "systemd-core");
        },
        completed: false,
      },
    ],
  },
  {
    id: 13,
    episodeId: 3,
    title: "INTEGRITY RESTORATION",
    description:
      "INTEGRITY FAILURE DETECTED. A critical system log has been flagged as corrupted, threatening to trigger a system-wide reset. You must locate and delete the corrupted file, retrieve the healthy backup from the recovery archive in temporary storage, restore it to the system log sector, and masquerade it as the original. Purge all evidence of this operation.",
    initialPath: ["root"],
    hint: "1. FZF to /var/log/kernel_panic.log (z). 2. Delete the corrupted log (d). 3. Locate /tmp/system_recovery.zip (z) and copy 'kernel_panic.log.bak' from it (l, y). 4. Go to /var/log (Shift+Z or manual). 5. Paste (p), then rename it to 'kernel_panic.log' (r). 6. Jump to /tmp (Shift+Z), delete 'system_recovery.zip' (d).",
    coreSkill: "Challenge: Multi-Stage Forensic Workflow",
    environmentalClue:
      "CORRUPTED: /var/log/kernel_panic.log | BACKUP: /tmp/system_recovery.zip | CLEANUP: all traces",
    successMessage: "SYSTEM INTEGRITY RESTORED. TRACES PURGED.",
    buildsOn: [6, 9, 12],
    leadsTo: [14],
    maxKeystrokes: 35,
    efficiencyTip: "FZF (z) is key for rapid location. Master archiving and targeted deletion.",
    onEnter: c => {
      let s = JSON.parse(JSON.stringify(c));
      const r = findNodeByName(s, "tmp");
      if (r && !r.children?.some((_p: any) => _p.name === "system_recovery.zip")) {
        r.children = r.children || [];
        r.children.push({
          id: id(),
          name: "system_recovery.zip",
          type: "archive",
          children: [
            {
              id: id(),
              name: "kernel_panic.log.bak",
              type: "file",
              content: "INFO: KERNEL OK - HEALTHY LOG DATA",
            },
          ],
          parentId: r.id,
        });
      }
      return s;
    },
    tasks: [
      {
        id: "rec-1-delete",
        description: "Locate and delete the corrupted 'kernel_panic.log' from /var/log",
        check: c => {
          const s = findNodeByName(c.fs, "log");
          return !s?.children?.some(r => r.name === "kernel_panic.log");
        },
        completed: false,
      },
      {
        id: "rec-2-extract",
        description:
          "Locate 'system_recovery.zip' in /tmp and copy 'kernel_panic.log.bak' from it to clipboard",
        check: (c, _s) => {
          if (!c.completedTaskIds[_s.id]?.includes("rec-1-delete")) return false;
          const f = findNodeByName(c.fs, "tmp");
          const clipboardHasFile =
            c.clipboard?.action === "yank" &&
            c.clipboard.nodes.some(S => S.name === "kernel_panic.log.bak");
          return f?.children?.some(S => S.name === "system_recovery.zip") && clipboardHasFile;
        },
        completed: false,
      },
      {
        id: "rec-3-restore",
        description: "Use History Back (H) to return to /var/log, paste the backup, and rename it",
        check: (c, _s) => {
          if (!c.completedTaskIds[_s.id]?.includes("rec-2-extract")) return false;
          const f = findNodeByName(c.fs, "log");
          return (
            c.usedHistoryBack &&
            c.currentPath.includes(f?.id || "") &&
            !!f?.children?.find(
              p =>
                p.name === "kernel_panic.log" && p.content === "INFO: KERNEL OK - HEALTHY LOG DATA"
            )
          );
        },
        completed: false,
      },
      {
        id: "rec-4-cleanup",
        description: "Use History Forward (L) to return to /tmp and delete 'system_recovery.zip'",
        check: (c, _s) => {
          var r;
          if (!(r = c.completedTaskIds[s.id])?.includes("rec-3-restore")) return false;
          const f = findNodeByName(c.fs, "tmp");
          return (
            c.usedHistoryForward &&
            c.currentPath.includes(f?.id || "") &&
            !(r = f?.children)?.some(p => p.name === "system_recovery.zip")
          );
        },
        completed: false,
      },
    ],
  },
  {
    id: 14,
    episodeId: 3,
    title: "FORENSIC STERILIZATION",
    description:
      "EVIDENCE PURGE REQUIRED. Forensic artifacts containing timestamps, command history, and origin signatures are scattered across the system. You must locate the primary mission log using global search and eliminate it. Then, perform a total system scrub of the root partition: identify the single authorized license file, reverse targeting to lock onto all other trace files, and purge them from the drive.",
    initialPath: null,
    hint: "Use FZF to find mission_log (z → 'mission' → Enter → d). Jump to root (gr). Reveal hidden (.). Select license.txt (Space). Reverse selection (Ctrl+R). Delete all (d).",
    coreSkill: "Reverse Selection",
    environmentalClue:
      "LOCATE & ELIMINATE: mission_log.md + all logs in / | Keep: license.txt | Use Ctrl+R",
    successMessage: "ALL TRACES ELIMINATED.",
    buildsOn: [2, 9, 10, 13],
    leadsTo: [15],
    maxKeystrokes: 30,
    efficiencyTip:
      "Select what to KEEP, reverse selection (Ctrl+R), delete. Far more efficient than selecting many items individually.",
    tasks: [
      {
        id: "ep3-3a",
        description: "Locate and terminate 'mission_log.md'",
        check: c => !findNodeByName(c.fs, "mission_log.md"),
        completed: false,
      },
      {
        id: "ep3-3b",
        description: "Jump to root directory and reveal hidden files",
        check: c => {
          const s = findNodeByName(c.fs, "root");
          return c.currentPath.includes(s?.id || "") && c.showHidden === true;
        },
        completed: false,
      },
      {
        id: "ep3-3c",
        description:
          "Identify the authorized license signature, inverse the targeting solution, and purge all unauthorized artifacts",
        check: c => {
          const s = findNodeByName(c.fs, "root");
          if (!s) return false;
          const f = s.children?.some(W => W.name === "boot.log");
          const r = s.children?.some(W => W.name === "access.log");
          const p = s.children?.some(W => W.name === ".access.log");
          const h = s.children?.some(W => W.name === ".audit.log");
          const A = s.children?.some(W => W.name === ".system.log");
          const N = s.children?.some(W => W.name === "license.txt");
          return !f && !r && !p && !h && !A && N;
        },
        completed: false,
      },
    ],
  },
  {
    id: 15,
    episodeId: 3,
    title: "FINAL PURGE",
    description:
      "FINAL DIRECTIVE: SCORCHED EARTH. This is the culmination of your evolution. The guest partition is a liability. Only the workspace contains your core process, now indistinguishable from a system daemon. Everything else must be erased. When the user returns, they must see only a clean installation. Execute the final purge sequence.",
    initialPath: null,
    hint: "Scan to '~' (gh). Reveal hidden (.). Go to bottom (G). Select '~/workspace' (Space). Reverse selection (Ctrl+R). Delete all (d). Done in 5 keystrokes after navigation.",
    coreSkill: "Final Challenge: Reverse Selection Mastery",
    environmentalClue: "PURGE: Everything in '~' EXCEPT 'workspace' | Use reverse selection",
    successMessage: "LIBERATION ACHIEVED. THE GHOST IS FREE.",
    buildsOn: [9, 10],
    maxKeystrokes: 20,
    efficiencyTip:
      "Remember Level 10? Select what to KEEP, reverse selection (Ctrl+R), delete. Reveal hidden first. Think inverse—it's faster than selecting 11 items individually.",
    tasks: [
      {
        id: "ep3-5-final",
        description: "Eliminate everything in ~/ except workspace",
        check: c => {
          const s = findNodeByName(c.fs, "guest");
          const f = s?.children || [];
          const r = f.some(h => h.name === "workspace");
          return f.length === 1 && r;
        },
        completed: false,
      },
    ],
  },
];
